<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Languages, Systems, and Data Lab @ UCSC on Languages, Systems, and Data Lab @ UCSC</title>
    <link>http://lsd.ucsc.edu/</link>
    <description>Recent content in Languages, Systems, and Data Lab @ UCSC on Languages, Systems, and Data Lab @ UCSC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 23 Mar 2022 10:27:25 -0700</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Languages, Systems, and Data Seminar (Spring 2022x)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2022sp/</link>
      <pubDate>Wed, 23 Mar 2022 10:27:25 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2022sp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For spring 2022, we will continue to host the LSD Seminar on Zoom, but local folks can gather in person in the lab to tune into the Zoom talks together, assuming in-person meetings are allowed.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-1&#34;&gt;April 1&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Olivia Hsu&lt;/td&gt;
&lt;td&gt;Compilation of Sparse Array Programming Models&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-8&#34;&gt;April 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Suyash Gupta&lt;/td&gt;
&lt;td&gt;Resilient and Scalable Architecture for Permissioned Blockchain Fabrics&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-15&#34;&gt;April 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Amanda Liu&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-22&#34;&gt;April 22&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Will Crichton&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-29&#34;&gt;April 29&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Slim Lim and Geoffrey Litt&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-6&#34;&gt;May 6&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Asta From&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-13&#34;&gt;May 13&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Farid Zakaria&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-20&#34;&gt;May 20&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Michael Coblenz&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-27&#34;&gt;May 27&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Douglas Creager&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#june-3&#34;&gt;June 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Yao Li&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;april-1&#34;&gt;April 1&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Olivia Hsu&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Compilation of Sparse Array Programming Models&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; This talk explains how to compile sparse array programming languages. A sparse array programming language is an array programming language that supports element-wise application, reduction, and broadcasting of arbitrary functions over dense and sparse arrays with any fill value. Such a language has great expressive power and can express sparse and dense linear and tensor algebra, functions over images, exclusion and inclusion filters, and even graph algorithms. This talk describes our compiler strategy, which generalizes prior work in the literature on sparse tensor algebra compilation to support any function applied to sparse arrays, instead of only addition and multiplication. To achieve this, we generalize the notion of sparse iteration spaces beyond intersections and unions. These iteration spaces are automatically derived by considering how algebraic properties annotated onto functions. We then show how to compile these iteration spaces to efficient code.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Olivia is a computer science PhD student at Stanford University advised by Professor Kunle Olukotun and Professor Fredrik Kjolstad. She currently works on mapping sparse applications to domain-specific architectures, reconfigurable dataflow hardware, and accelerators through the TACO compiler. Her research interests broadly include computer architecture, computer and programming systems, compilers, programming models and languages, and digital circuits/VLSI.&lt;/p&gt;

&lt;h1 id=&#34;april-8&#34;&gt;April 8&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Suyash Gupta&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Resilient and Scalable Architecture for Permissioned Blockchain Fabrics&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Since the introduction of Bitcoin—the first widespread application driven by blockchains—the interest in the design of blockchain-based applications has increased tremendously. At the core of these blockchain applications are consensus protocols that aim at securely replicating a client request among all replicas, even if some replicas are Byzantine faulty. Unfortunately, modern consensus protocols either yield low throughput or face design limitations.
In this work, we present the design of three consensus protocols that facilitate efficient consensus among the replicas. Our protocols help to scale consensus through the principles of phase-reduction, parallelization, and geo-scale clustering while ensuring no compromise in fault-tolerance. Further, we believe that the focus on consensus protocols is only one-side of the story. Specifically, we present the design of a well-crafted permissioned blockchain fabric (ResilientDB) that can help even a slow consensus protocol outperform a faster protocol. Our results indicate that it is easy to scale BFT protocols to hundreds of replicas and achieve throughputs of the order 350K txns/s.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Suyash Gupta is a postdoctoral researcher at the RISELab, University of California, Berkeley. He is also the Lead Architect of ResilientDB fabric. Prior to joining RISELab, he received his Ph.D. degree from University of California, Davis. He also holds two Master of Science degrees; one from Purdue University and another from Indian Institute of Technology Madras. His current research focuses on attaining safe and efficient, fault tolerant distributed consensus and communication. He has also co-authored a book on fault-tolerant distributed transaction processing at Morgan &amp;amp; Claypool. In his free time, Suyash likes to code and has won awards at several hackathons.&lt;/p&gt;

&lt;h1 id=&#34;april-15&#34;&gt;April 15&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Amanda Liu&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;april-22&#34;&gt;April 22&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Will Crichton&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;april-29&#34;&gt;April 29&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speakers:&lt;/strong&gt; Slim Lim and Geoffrey Litt&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;may-6&#34;&gt;May 6&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Asta From&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;may-13&#34;&gt;May 13&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Farid Zakaria&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;may-20&#34;&gt;May 20&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Michael Coblenz&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;may-27&#34;&gt;May 27&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Douglas Creager&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;june-3&#34;&gt;June 3&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Yao Li&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Winter 2022)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2022wi/</link>
      <pubDate>Mon, 03 Jan 2022 14:46:51 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2022wi/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For winter 2022, we will continue to host the LSD Seminar on Zoom, but local folks can gather in person in the lab to tune into the Zoom talks together, assuming in-person meetings are allowed.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-7&#34;&gt;Jan. 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Dev Purandare&lt;/td&gt;
&lt;td&gt;Append is Near: Log-based Data Management on ZNS SSDs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-14&#34;&gt;Jan. 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Max Willsey&lt;/td&gt;
&lt;td&gt;What&amp;rsquo;s up with E-Graphs?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-21&#34;&gt;Jan. 21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jonathan Castello&lt;/td&gt;
&lt;td&gt;Simulating spacecraft: Not exactly rocket science&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-28&#34;&gt;Jan. 28&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Reese Levine&lt;/td&gt;
&lt;td&gt;A Strong Approach to Testing Weak Memory Models&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-4&#34;&gt;Feb. 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Kostis Kaffes&lt;/td&gt;
&lt;td&gt;Syrup: User-Defined Scheduling across the Stack&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-11&#34;&gt;Feb. 11&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Tzu-Han Hsu&lt;/td&gt;
&lt;td&gt;Bounded Model Checking for Hyperproperties&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-18&#34;&gt;Feb. 18&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Matthew Weidner&lt;/td&gt;
&lt;td&gt;Designing for Eventual Consistency with Simple, Composable CRDTs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-25&#34;&gt;Feb. 25&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jocelyn Chen&lt;/td&gt;
&lt;td&gt;Web question answering with neurosymbolic program synthesis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-4&#34;&gt;March 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Jie Zhou&lt;/td&gt;
&lt;td&gt;Fat Pointers for Temporal Memory Safety of C&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-11&#34;&gt;March 11&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Sorawee Porncharoenwase&lt;/td&gt;
&lt;td&gt;An Expressive and Optimal Pretty Printer&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;jan-7&#34;&gt;Jan. 7&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Dev Purandare&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Append is Near: Log-based Data Management on ZNS SSDs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Log-based data management systems use storage as if it was an append-only medium in order to transform random writes into sequential writes, delivering a major advantage when logs were persisted on hard disks. Although solid-state drives (SSDs) offer improved random write capabilities, sequential writes continue to be advantageous due to locality and space efficiency. However, the inherent properties of flash-based SSDs induce significant disadvantages when utilizing a random write block interface, causing write amplification, uneven wear, log stacking, and garbage collection overheads. To eliminate these disadvantages, Zoned Namespace (ZNS) SSDs have recently been introduced. They offer increased capacity, reduced write amplification, and higher performance but require the host to participate in data placement through zones, which have sequential-write semantics and must be explicitly reset. In ZNS, the Zone Append primitive allows the host to push down fine-grained data placement onto the device, supporting appends to a zone without knowing the location of the tail. Full zones become immutable, greatly simplifying disaggregated storage and operations like replication.&lt;/p&gt;

&lt;p&gt;We propose another pushdown technique, Group Append, which allows appends of data that is smaller (or possibly larger) than a block, offloading data buffering to the controller. We explore how ZNS SSDs with Zone Append, Group Append, and computational storage can benefit four log-based data management areas: (i) log-based file systems, (ii) LSM trees such as RocksDB, (iii) database systems, and (iv) event logs/shared logs. We also propose research directions for all four log-based data management using ZNS SSDs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Dev is a PhD candidate in the Computer Science department at University of California Santa Cruz. His research interests lie in storage systems, operating systems and distributed systems, and programming languages. Dev completed his Bachelor&amp;rsquo;s in Computer Engineering at Savitribai Phule Pune University (SPPU) in India. At UCSC he has been working on improving the lifetime of low cost, low reliability SSDs and evolving systems for Zoned Namespace SSDs. Dev has been an Engineering Intern at Riverbed Networks (2017), and an Architecture Enabling Intern at SK Hynix America Ltd. (2019). He can be found on twitter (@dev14e), LinkedIn (devashishp), and email (devashish@ucsc.edu).&lt;/p&gt;

&lt;h1 id=&#34;jan-14&#34;&gt;Jan. 14&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Max Willsey&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; What&amp;rsquo;s up with E-Graphs?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; E-graphs are an important data structure inside SMT solvers, but recently they have been used for a whole lot more, including optimization, program synthesis, and verification!&lt;/p&gt;

&lt;p&gt;This talk will give a whirlwind introduction to e-graphs and equality saturation, as well as some new algorithms that make them faster. I&amp;rsquo;ll also introduce &lt;a href=&#34;https://egraphs-good.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;egg&lt;/a&gt;, a toolchain that packages all this up into a generic, reusable library. Then, we&amp;rsquo;ll move on to some applications of these new techniques, including floating point accuracy, 3D CAD, deep learning, and more. Finally, I&amp;rsquo;ll talk about some of the current work folks are using egg for, including a teaser for our &lt;a href=&#34;https://arxiv.org/abs/2108.02290&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;upcoming POPL paper&lt;/a&gt; that connects e-graphs to databases.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://www.mwillsey.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Max&lt;/a&gt; is a postdoc at the University of Washington in the &lt;a href=&#34;http://uwplse.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;PLSE&lt;/a&gt; group, where he also did his PhD. His main line of work is on &lt;a href=&#34;https://egraphs-good.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;egg&lt;/a&gt;, an e-graph and equality saturation toolkit.&lt;/p&gt;

&lt;h1 id=&#34;jan-21&#34;&gt;Jan. 21&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jonathan Castello&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Simulating spacecraft: Not exactly rocket science&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Caltech&amp;rsquo;s Jet Propulsion Laboratory (JPL) operates a fleet of autonomous spacecraft across our solar system. For more than thirty years, operators have validated planned activities against a simulated model of their spacecraft in order to preserve these valuable resources. These models are typically implemented in a domain-specific language (a DSL), which is then interpreted for an execution plan by reusable simulation systems.&lt;/p&gt;

&lt;p&gt;As we make our spacecraft even more intelligent, our spacecraft models become correspondingly more complex. Existing simulation systems were designed with a minimal DSL and limited scope, and have been significantly expanded under a constant flow of feature requests. Unfortunately, this has led to simulation systems and models that are difficult to understand and maintain without relying on global reasoning and deep expertise.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/NASA-AMMOS/aerie/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Merlin&lt;/a&gt; is a newly open-sourced simulation system under development at JPL. Merlin models are written in plain Java, which we try to make as &amp;ldquo;uninteresting&amp;rdquo; as possible for modelers. Instead, we spend our &amp;ldquo;novelty budget&amp;rdquo; mostly under the hood. This talk will showcase the concurrency semantics supporting local reasoning in Merlin, and some of the techniques we take to keep Merlin out of the way.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://jonathan.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jonathan Castello&lt;/a&gt; is a software engineer most recently with Caltech&amp;rsquo;s Jet Propulsion Laboratory, where he worked on both modern and legacy ground software for spacecraft operations. His research interests sit at the nexus of modular design, concurrency, and monotonic state.&lt;/p&gt;

&lt;h1 id=&#34;jan-28&#34;&gt;Jan. 28&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Reese Levine&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; A Strong Approach to Testing Weak Memory Models&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; GPUs are increasingly being used for compute workloads that require interactions between threads using shared memory. Like many CPUs, GPUs expose weak memory models that allow for more aggressive compiler and hardware optimizations at the expense of a more complex programming model. Testing these memory models is an ongoing line of research.&lt;/p&gt;

&lt;p&gt;This talk will detail our ongoing project on testing GPU memory models. First, we will show a motivating example from an optimized renderer and illustrate how we can reason about the synchronization in the renderer using classic weak memory model litmus tests. Next, we will overview recent work on testing GPU memory models, including complex heuristics necessary to reveal weak behaviors in testing. Our new work builds on this existing work in several ways: (1) we provide a simple DSL and a compiler for expressing litmus tests and testing heuristics; we currently have backends for Vulkan and WebGPU. (2) A new parallel execution model for litmus tests, which allows tests to be executed an order of magnitude faster than in prior works. (3) A web application interface for running litmus tests through WebGPU. We will conclude with a discussion on how these contributions might lead to more robust testing methodologies and hope to facilitate discussions on how they relate to conformance testing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Reese Levine is a second year PhD student at UC Santa Cruz advised by Tyler Sorensen. He is interested in research in parallel, concurrent, and distributed systems, and his work currently focuses on testing weak memory models in GPUs.&lt;/p&gt;

&lt;h1 id=&#34;feb-4&#34;&gt;Feb. 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Kostis Kaffes&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Syrup: User-Defined Scheduling across the Stack&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Suboptimal scheduling decisions in operating systems, networking stacks, and application runtimes are often responsible for poor application performance, including higher latency and lower throughput. These poor decisions stem from a lack of insight into the applications and requests the scheduler is handling and a lack of coherence and coordination between the various layers of the stack, including NICs, kernels, and applications. We propose Syrup, a framework for user-defined scheduling. Syrup enables untrusted application developers to express application-specific scheduling policies across these system layers without being burdened with the low-level system mechanisms that implement them. Application developers write a scheduling policy with Syrup as a set of matching functions between inputs (threads, network packets, network connections) and executors (cores, network sockets, NIC queues) and then deploy it across system layers without modifying their code. Syrup supports multi-tenancy as multiple co-located applications can each safely and securely specify a custom policy. We present several examples of uses of Syrup to define application and workload-specific scheduling policies in a few lines of code, deploy them across the stack, and improve performance up to 8x compared with default policies.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kostis Kaffes is a final-year Ph.D. candidate in Electrical Engineering at Stanford University, advised by Christos Kozyrakis. He is broadly interested in computer systems, cloud computing, and scheduling. His thesis focuses on end-host, rack-scale, and cluster-scale scheduling for microsecond-scale tail latency. Recently, he has been looking for ways to make it easier to implement and deploy custom scheduling policies across different layers of the stack. Kostis&amp;rsquo;s research has been supported by a Facebook Research Award and various scholarships and fellowships from Stanford, A.G. Leventis Foundation, and Gerondelis Foundation. Prior to Stanford, he received his undergraduate degree in Electrical and Computer Engineering from the National Technical University of Athens in Greece.&lt;/p&gt;

&lt;h1 id=&#34;feb-11&#34;&gt;Feb. 11&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Tzu-Han Hsu&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Bounded Model Checking for Hyperproperties&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Hyperproperties is a powerful framework for specifying and reasoning about important classes of requirements that were not possible with trace-based languages such as the classic temporal logics. This talk will introduce a novel bounded model checking (BMC) algorithm for hyperproperties expressed in HyperLTL. Just as the classic BMC technique for LTL primarily aims at finding bugs, our approach also targets identifying counterexamples. Followed by the reduction of BMC for LTL to SAT solving, our BMC approach naturally reduces to QBF solving, as HyperLTL allows explicit and simultaneous quantification over multiple traces. Our algorithm is sound based on our theory of bounded semantics, which guarantees correct BMC results under finite exploration. We will also present our implemented tool HyperQube, a push-button QBF-based bounded model checker for hyperproperties, and demonstrate the effectiveness and efficiency of our approach via a rich set of practical applications, including security, concurrent data structures, path planning for multi-agent systems, and secrecy-preserving refinement mapping synthesis.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Tzu-Han Hsu is a second-year Ph.D. student in Computer Science and Engineering department at Michigan State University, advised by Dr. Borzoo Bonakdarpour. Her research areas include formal methods, model checking, verification, and synthesis for security/privacy policies. She is recently working on the topic of hyperproperties, a framework that can reason about multiple traces simultaneously, which has rich applications in formal analysis especially for multi-threaded and concurrent programs.&lt;/p&gt;

&lt;p&gt;Before MSU, Tzu-Han received her bachelor’s degrees in Computer Science and Music-Piano Performance from Iowa State University in 2020. Tzu-Han can be reached on Twitter (@TzuHanH), LinkedIn (tzuhanhsu), email (tzuhan@msu.edu), and her personal website (&lt;a href=&#34;https://tzuhancs.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://tzuhancs.github.io/&lt;/a&gt;).&lt;/p&gt;

&lt;h1 id=&#34;feb-18&#34;&gt;Feb. 18&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Matthew Weidner&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Designing for Eventual Consistency with Simple, Composable CRDTs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Many distributed systems allow a group of devices to edit some shared state. Examples include collaborative apps, such as Google Docs and Figma, and distributed key-value stores. Often, these systems are highly available: each device can edit its own replica of the state immediately, then sync up with other devices in the background. Eventual consistency requires that once this syncing completes, all devices agree on the new state.&lt;/p&gt;

&lt;p&gt;Eventual consistency is challenging because devices might make conflicting concurrent edits. For example, two users might type at the same time in a Google Doc, or one user might add entries to a spreadsheet while another alters the layout and formatting. Somehow, we must combine all these edits in a way that is consistent across devices and hopefully also makes sense to users. Conflict-free Replicated Data Types (CRDTs) provide one solution to this challenge, by giving programmers data structures with built-in replication and eventual consistency. However, they tend to be hard to understand or customize.&lt;/p&gt;

&lt;p&gt;In this talk, I will propose a way of creating CRDTs by composing simple, easy-to-understand pieces. Ideally, this could let programmers design eventually consistent systems while maintaining complete control over the system&amp;rsquo;s behavior. A &lt;a href=&#34;https://mattweidner.com/2022/02/10/collaborative-data-design.html&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;blog post&lt;/a&gt; describes the proposal in more detail.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://mattweidner.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Matthew&lt;/a&gt; is a third year PhD student at Carnegie Mellon University, advised by Heather Miller. His research focuses on tools for decentralized systems, with a particular interest in enabling open-source, local-first collaborative apps. Previously, he completed an MPhil at Cambridge University as a Churchill Scholar, where he studied decentralized secure group messaging protocols for the &lt;a href=&#34;https://www.cl.cam.ac.uk/research/dtg/trve/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;TRVE Data&lt;/a&gt; project.&lt;/p&gt;

&lt;h1 id=&#34;feb-25&#34;&gt;Feb. 25&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jocelyn Chen&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Web question answering with neurosymbolic program synthesis&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; As the amount of information available on the web proliferates, there is a growing need for tools that can extract relevant information from the website. Due to the importance of the problem, there has been a flurry of research activity on information extraction and wrapper induction by using powerful neural models and program synthesis. While wrapper induction tools based on program synthesis work well when the target webpages have a shared global schemes, they are not as effective on structurally heterogeneous websites such as faculty webpages. On the other hand, ML-based techniques from the NLP community are, in principal, applicable to heterogeneous websites; however, by treating the entire webpage as unstructured texts, they fail to take advantage of the inherent tree structure of the HTML documents.&lt;/p&gt;

&lt;p&gt;In this talk, we propose a new information extraction approach based on neurosymbolic program synthesis that combines the relative strengths of wrapper induction techniques for webpages with the flexibility of neural models for unstructured documents. Our approach targets structurally heterogeneous websites with no shared global schema and can be used to automate many different types of information extraction tasks. The key idea of our approach is to employ a neurosymbolic DSL that incorporates both neural NLP models as well as standard language constructs for tree navigation and string manipulation. We also propose an optimal synthesis algorithm that generates all DSL programs that achieve optimal F1 score on the training examples. We have implemented these ideas in a new tool called WebQA and evaluate it on 25 different tasks across multiple domains. Our experiments show that WebQA significantly outperforms existing tools such as state-of-the-art question answering models and wrapper induction systems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Jocelyn Chen is a fourth-year graduate student at the University of Texas at Austin working with Isil Dillig. She is mainly interested in research at the intersection of program synthesis and natural language processing.&lt;/p&gt;

&lt;h1 id=&#34;march-4&#34;&gt;March 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Jie Zhou&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Fat Pointers for Temporal Memory Safety of C&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The past decade has seen an increasing trend of real-world exploits against temporal memory safety bugs in C/C++ programs, i.e., use-after-free (UAF), double free, and invalid free. These bugs are profoundly dangerous in that they can lead to data corruption, information leaking, or even arbitrary code execution.  Many solutions were proposed, but they suffer one or more severe limitations such as high performance/memory overhead and missing bugs.&lt;/p&gt;

&lt;p&gt;In this talk, I will describe how we solve this problem for C efficiently and comprehensively. We combine two existing techniques: fat pointers (in-place metadata) and ID-based dynamic pointer validation. We build our solution based on Checked C–a promising safe dialect of C which provides spatial memory safety but currently lacks temporal memory safety. We show that our solution significantly improves the performance and memory consumption compared to using disjoint metadata for pointer validation. Additionally, we also show that our solution is practical in terms of backward compatibility–one of the major concerns about fat pointers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.rochester.edu/u/jzhou41/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jie Zhou&lt;/a&gt; is a fifth-year PhD student at the University of Rochester. Jie works on systems and software security, with a focus on memory safety. He is most interested in improving systems programming languages and their toolchains for security as he believes that language-based techniques can solve problems in a more fundamental way. He is also interested in developing program analysis and transformation techniques to enforce security policies on low-level software.&lt;/p&gt;

&lt;h1 id=&#34;march-11&#34;&gt;March 11&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Sorawee Porncharoenwase&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; An Expressive and Optimal Pretty Printer&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Pretty printers transform structured data into &amp;ldquo;pretty&amp;rdquo; text. In this talk, I will present a pretty printing algorithm that (1) is strictly more expressive than current state-of-the-art algorithms; (2) guarantees optimality; and (3) has better time complexity than many state-of-the-art pretty printers. To distinguish our pretty printer from others, I will also give a brief survey of the existing pretty printing algorithms and dispel various myths about traditional pretty printers that turn out to be inaccurate. This is a joint work with Justin Pombrio and Emina Torlak.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Sorawee (Oak) is a fourth year PhD student at the University of Washington, advised by Emina Torlak. His research interest is improving usability of symbolic evaluation.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Fall 2021)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2021fa/</link>
      <pubDate>Tue, 31 Aug 2021 19:47:53 -0700</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2021fa/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:05pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For fall 2021, we will continue to host the LSD Seminar on Zoom, but local folks can gather in person in the lab to tune into the Zoom talks together.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#sept-24&#34;&gt;Sept. 24&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Welcome!&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-1&#34;&gt;Oct. 1&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://maria-a-schett.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Maria Schett&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Cheaper (&amp;amp; correct) blockchain protocols and programs&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-8&#34;&gt;Oct. 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://web.eecs.umich.edu/~takh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Tanvir Ahmed Khan&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Rescuing Data Center Processors&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-15&#34;&gt;Oct. 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.seas.upenn.edu/~edinella/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Elizabeth Dinella&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Data Driven Program Merge&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-22&#34;&gt;Oct. 22&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cmi.ac.in/~vaishnavi/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Vaishnavi Sundararajan&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Better Safe than Sorry: Symbolic Verification for Security Protocols&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-29&#34;&gt;Oct. 29&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.cmu.edu/~jlwise/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jenna Wise&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Gradual Verification of Recursive Heap Data Structures&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-5&#34;&gt;Nov. 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://thok.eu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Thomas Koehler&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Optimizing Processing Pipelines with a Rewrite-Based Domain-Extensible Compiler&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-12&#34;&gt;Nov. 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://giuliaguidi.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Giulia Guidi&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Sparse Matrices and High-Performance Computing Meet Biology&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-19&#34;&gt;Nov. 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.utexas.edu/~hleblanc/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Hayley LeBlanc&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Finding Crash Consistency Bugs in Persistent Memory File Systems&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-3&#34;&gt;Dec. 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://sydgibs.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Sydney Gibson&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Efficient Verification of High-Performance Cryptographic Routines on New Hardware&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;sept-24&#34;&gt;Sept. 24&lt;/h1&gt;

&lt;p&gt;Welcome!&lt;/p&gt;

&lt;h1 id=&#34;oct-1&#34;&gt;Oct. 1&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://maria-a-schett.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Maria Schett&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Cheaper (&amp;amp; correct) blockchain protocols and programs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; We will explore how we can make it cheaper to run blockchain protocols and programs&amp;mdash;while guaranteeing correctness!&lt;/p&gt;

&lt;p&gt;For cheaper protocols, we move from a block&lt;em&gt;chain&lt;/em&gt; to a block&lt;em&gt;graph&lt;/em&gt;. Such a blockgraph, which we show to be a reliable point-to-point link, is built together by a set of servers. Thereby, the servers embed many parallel runs of a deterministic protocol into it. And because the protocol is deterministic, every server can locally replay the protocol&amp;mdash;and no more messages need to be sent [1]!&lt;/p&gt;

&lt;p&gt;For cheaper programs, we super-optimize bytecode of the Ethereum Virtual Machine, which runs on many servers to execute programs on the blockchain. Now, to avoid the halting problem, every executed bytecode costs money. So we have a clear optimization target&amp;mdash;money&amp;mdash;and we use an automated theorem prover to synthesize cheaper, observationally equivalent, programs [2].&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; &lt;a href=&#34;https://maria-a-schett.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Maria A Schett&lt;/a&gt; is currently finishing her PhD on &amp;ldquo;Cost Reduction With Guarantees: Formal Reasoning Applied To Blockchain Technologies&amp;rdquo; at University College London. She loves living in London and talking about blockchains, distributed systems, and compilers. She is conversational in term rewriting and qualitative research (from a previous life) and in Esperanto.&lt;/p&gt;

&lt;p&gt;[1] &amp;ldquo;Embedding a Deterministic BFT Protocol in a Block DAG&amp;rdquo;, Maria A Schett and George Danezis, Proc. of the 2021 ACM Symposium on Principles of Distributed Computing (PODC) 2021&lt;/p&gt;

&lt;p&gt;[2] &amp;ldquo;Synthesis of Super-Optimized Smart Contracts using Max-SMT&amp;rdquo;, Elvira Albert, Pablo Gordillo, Albert Rubio and Maria A Schett, Proc. of 32nd International Conference on Computer-Aided Verification (CAV) 2020&lt;/p&gt;

&lt;h1 id=&#34;oct-8&#34;&gt;Oct. 8&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://web.eecs.umich.edu/~takh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Tanvir Ahmed Khan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Rescuing Data Center Processors&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; To serve billions of users around the world, modern web applications that run across data centers access huge datasets and perform complex application logic. As a result, data center applications face two major challenges: (1) poor data access behavior and (2) poor instruction access behavior. In my research, I demonstrate that novel hardware-software codesign effectively solves both challenges. Specifically, I observe that both data and instruction accesses in data center applications follow a deeply repetitive pattern that can be efficiently optimized by profiling the application’s program flow behavior. In this talk, I will first present an overview of my techniques to improve data and instruction accesses. I will then describe two of my techniques in detail, showing how these techniques outperform prior proposals from Google.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Tanvir Ahmed Khan is a fifth-year Ph.D. candidate at the University of Michigan. His research interests lie at the intersection of computer architecture, compilers, and operating systems. He is interested in designing techniques at the boundary of hardware and software that enable software to better leverage hardware resources. He was a Facebook Fellowship (2020) finalist. His research on data center applications’ performance optimizations has appeared in top computer architecture and systems venues like ISCA, MICRO, PLDI, and OSDI. His work is being used by Intel and ARM to design the next-generation CPU architectures. Tanvir expects to graduate soon and after graduation, he is interested in tenure-track faculty positions.&lt;/p&gt;

&lt;h1 id=&#34;oct-15&#34;&gt;Oct. 15&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://www.seas.upenn.edu/~edinella/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Elizabeth Dinella&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Data Driven Program Merge&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In collaborative software development, &lt;em&gt;program merging&lt;/em&gt; is the mechanism to integrate changes from multiple programmers. The most widespread merge algorithm, employed in modern version control systems, is an &lt;em&gt;unstructured&lt;/em&gt; merge. Unstructured merge treats input programs as a sequence of characters and reports a conflict when changes interfere textually. On the other hand, &lt;em&gt;structured&lt;/em&gt; approaches leverage knowledge of the underlying language to perform “intelligent” merges over the program’s AST. These approaches have shown significant advancements in automatic merging for Java. However, these methods have not found their way into modern version control systems as they are typically language dependent and do not generalize to dynamic languages such as JavaScript.&lt;/p&gt;

&lt;p&gt;In a 1991 seminal paper on program merge [1], Westfechtel voiced: “A tool is &lt;em&gt;urgently&lt;/em&gt; needed which automates the process of merging as much as possible.”  Thirty years later, and there have not been significant advances in the prevailing merge algorithm - unstructured merge.&lt;/p&gt;

&lt;p&gt;In this work, we take a &lt;em&gt;fresh data-driven&lt;/em&gt; look at the problem of merge resolution. Guided by a multilingual dataset of over 200,000 merges, we explore deep learning techniques to resolve unstructured merge conflicts. Our key innovation is an edit-aware embedding of merge inputs.&lt;/p&gt;

&lt;p&gt;Our resulting model achieves 63&amp;ndash;68% accuracy of merge resolution synthesis, yielding nearly a 3x performance improvement over existing structured merge tools. Finally, we demonstrate that our approach is sufficiently flexible to work with source code files in Java, JavaScript, TypeScript, and C# programming languages, and can generalize zero-shot to unseen languages.&lt;/p&gt;

&lt;p&gt;[1] Bernhard Westfechtel. 1991. Structure-oriented merging of revisions of software documents. In &lt;em&gt;Proceedings of the 3rd international workshop on Software configuration management&lt;/em&gt; (SCM &amp;lsquo;91).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Elizabeth Dinella is a fourth-year PhD student at the University of Pennsylvania. Her research interests can be broadly described as “data-driven program reasoning.” Most recently, Elizabeth has worked on data-driven bug finding (&lt;a href=&#34;https://openreview.net/pdf?id=SJeqs6EFvB&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Hoppity&lt;/a&gt;), program merge, and test oracle inference. She is an admirer of coffee and her chow chow puppy Cinnabon.&lt;/p&gt;

&lt;h1 id=&#34;oct-22&#34;&gt;Oct. 22&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cmi.ac.in/~vaishnavi/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Vaishnavi Sundararajan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Better Safe than Sorry: Symbolic Verification for Security Protocols&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; A large part of our lives is spent online, creating, sharing, and consuming data in various forms. We use a profusion of security protocols to handle this more-often-than-not sensitive data, and connect to the internet and to the world at large. How secure are these communications? How private? These are fundamental questions to which we demand definitive answers. Even with highly sophisticated methods of testing, one cannot get unconditional answers, and this is where formal verification steps in. One can use logic or automata or similar formal methods to conclusively tell us if there are security flaws in these protocols. In this talk, we will provide a quick and dirty introduction to the world of symbolic verification, with a focus on security protocols. We will then look at a few ways in which the protocols of today’s day and age are modelled and verified.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Vaishnavi Sundararajan is a postdoc at UCSC. She completed her PhD at Chennai Mathematical Institute, with a thesis on formal aspects of certification in security protocols. She is interested in the areas of logic, security, proof theory and verification. Before UCSC, she was a postdoc at IRISA, Rennes, and a Research Associate at Ericsson Research, Bengaluru.&lt;/p&gt;

&lt;h1 id=&#34;oct-29&#34;&gt;Oct. 29&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://www.cs.cmu.edu/~jlwise/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jenna Wise&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Gradual Verification of Recursive Heap Data Structures&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Current static verification techniques do not provide good support for incrementality, making it difficult for developers to focus on specifying and verifying the properties and components that are most important. Dynamic verification approaches support incrementality, but cannot provide static guarantees. To bridge this gap, prior work proposed gradual verification, which supports incrementality by allowing every assertion to be complete, partial, or omitted, and provides sound verification that smoothly scales from dynamic to static checking. Our OOPSLA’20 paper [1] extended gradual verification to programs that manipulate recursive, mutable data structures on the heap. This talk outlines our extension and discusses technical challenges addressed during its development, such as ensuring consistency between static and dynamic checking. I also present the design of a gradual verifier that we built as follow-up work to our OOPSLA paper. It is implemented on top of the Viper static verifier and supports the C0 programming language. The C0 language is a safer, smaller subset of C taught in introductory CS courses at CMU. Finally, I conclude the talk with my short-term plans to evaluate our tool&amp;mdash;which includes a case study on web browser JIT code&amp;mdash;and my long-term vision for the field of gradual verification.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I am a fifth year PhD student in the Institute for Software Research at Carnegie Mellon University, and I am co-advised by Jonathan Aldrich and Joshua Sunshine. My research interests lie at the intersection of programming languages, software verification, and software engineering. In general, I intend to make verification technology, like formal verification and program analysis, more usable in practice. Towards this end, my thesis is dedicated to work in gradual verification, which supports incremental formal verification through the use of both static and dynamic techniques. I have also used ideas from gradual verification to produce a gradual null pointer analysis [2] that reduces false positives compared to state-of-the-art tools. It systematically deploys run-time checks wherever the underlying static analysis is imprecise. Further, I previously contributed to the language design of Penrose &amp;mdash; which generates diagrams from mathematical prose &amp;mdash; and Obsidian &amp;mdash; a programming language that facilitates the development of secure blockchain applications. Outside of work, I enjoy playing video games, such as League of Legends and Final Fantasy XIV Online. I also enjoy bowling and often average more than 170 points per game!&lt;/p&gt;

&lt;p&gt;[1] Wise, J., Bader, J., Wong, C., Aldrich, J., Tanter, É., Sunshine, J., &amp;ldquo;Gradual Verification of Recursive Heap Data Structures&amp;rdquo;, The ACM SIGPLAN conference on Systems, Programming, Languages, and Applications: Software for Humanity (SPLASH20), OOPSLA, November 15-20, 2020, Online&lt;/p&gt;

&lt;p&gt;[2] Estep, S., Wise, J., Aldrich, J., Tanter, É., Bader, J., and Sunshine, J., &amp;ldquo;Gradual Program Analysis for Null Pointers&amp;rdquo;, The 35th European Conference on Object-Oriented Programming (ECOOP21), July 11-17, 2021, Online&lt;/p&gt;

&lt;h1 id=&#34;nov-5&#34;&gt;Nov. 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://thok.eu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Thomas Koehler&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Optimizing Processing Pipelines with a Rewrite-Based Domain-Extensible Compiler&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Domain-specific optimizing compilers such as Halide
enable programs to be expressed at a convenient high-level, while
generating high-performance code for parallel architectures. As
domains of interest expand towards deep learning, probabilistic
programming and beyond, it becomes increasingly clear that it is
unsustainable to redesign domain specific compilers for each new
domain. In addition, the rapid growth of hardware architectures to
optimize for poses great challenges for designing these compilers.&lt;/p&gt;

&lt;p&gt;In this talk, I will show how to extend a unifying domain-extensible
compiler with domain-specific as well as hardware-specific
optimizations.  Optimizations are not hard-coded into the compiler but
are expressed as user-defined rewrite rules that are composed into
strategies controlling the optimization process. On four mobile ARM
multi-core CPUs, the code generated for the Harris image processing
pipeline outperforms the image processing library OpenCV by up to 16x
and achieves performance close to - or even up to 1.4x better than -
the state-of-the-art image processing compiler Halide.&lt;/p&gt;

&lt;p&gt;However, optimization strategies are difficult to write because they
need to decide how to apply rewrite rules.  I will finish this talk by
presenting a technique we call &amp;ldquo;guided equality saturation via
sketching&amp;rdquo; to abstract over individual rewrites.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; I am a PhD student in computer science at the University of Glasgow in
Scotland, where I work closely with my supervisor Michel Steuwer. I am
the lead developer of the &lt;a href=&#34;https://rise-lang.org&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Rise project&lt;/a&gt;, which
combines a high-level functional language with a system of rewrite rules
to encode optimization choices. It provides a domain-extensible way to
generate high performance code for diverse hardware architectures.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://thok.eu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Personal website&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;nov-12&#34;&gt;Nov. 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://giuliaguidi.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Giulia Guidi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Sparse Matrices and High-Performance Computing Meet Biology&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In computational and data sciences, the need for scalable computing and data systems has recently increased due to the flood of data in areas such as genomics. Yet, scalable parallel programming in distributed memory is difficult, and high-performance computing (HPC) systems are typically allocated to specific research communities and have long user wait times, limiting access to resources and scientific discoveries.&lt;/p&gt;

&lt;p&gt;In this context, we have developed a novel set of genomics algorithms for de novo genome assembly (i.e., reconstruction of an unknown genome from redundant, erroneous genomic sequences) that are integrated into the diBELLA 2D software package and are based on sparse matrix multiplication supporting general semiring abstraction. This enables the creation and easy modification of powerful genomics pipelines that take advantage of massively parallel hardware without exposing low-level architecture. diBELLA 2D is up to 2x faster on 100s nodes than a 1D algorithm based on distributed hash tables, which are more difficult to parallelize. diBELLA 2D integrates GPU support in the most compute-intensive stages of the pipeline to take advantage of today&amp;rsquo;s heterogeneous HPC hardware.&lt;/p&gt;

&lt;p&gt;To ensure that the genomics research community and others in general, can benefit from HPC, the development of distributed algorithms such as diBELLA 2D must be coupled with efforts to make distributed computing more accessible. To this end, we have shown that we are on the cusp of a paradigm shift in high-performance computing (HPC) away from purely institutional or agency-wide HPC systems to cloud computing, as the latter has made significant advances in networking technology and HPC system software.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Giulia is a Ph.D. candidate in Computer Science at UC Berkeley and a graduate research assistant at the Computational Research Division of Lawrence Berkeley National Laboratory advised by Aydın Buluç and Kathy Yelick. Giulia is a 2020 SIGHPC Computational &amp;amp; Data Science Fellow and received her M.Sc. and B.Sc. in Biomedical Engineering from Politecnico di Milano. Her work is in the area of computer systems research, including cloud and parallel computing, and she is interested in building a collaborative interdisciplinary research program. Giulia is currently working on the challenges of large-scale computational biology, as well as the algorithms and software infrastructures that meet the usability and performance demand of this community. Currently, she is developing a novel algorithm for de novo assembly of genomes in distributed memory using long-read sequencing data and sparse matrix abstraction as part of the ExaBiome project. Giulia is also working on how to make cloud computing more accessible for high-performance scientific computing.&lt;/p&gt;

&lt;h1 id=&#34;nov-19&#34;&gt;Nov. 19&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://www.cs.utexas.edu/~hleblanc/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Hayley LeBlanc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Finding Crash Consistency Bugs in Persistent Memory File Systems&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Persistent memory (PM) is a new storage technology that combines the speed and byte-addressability of DRAM with the durability of hard disks and solid state drives. Recent research has explored using PM in a number of different applications like databases and file systems. However, programming PM applications correctly is difficult; in order for data to be guaranteed durable on PM, developers must understand and use a set of assembly instructions to manage persistence. In particular, PM applications are prone to crash consistency bugs, where buggy data management leads to incorrect behavior after a crash.&lt;/p&gt;

&lt;p&gt;PM file systems are a growing subset of PM applications, but there are currently no testing tools that target crash consistency bugs in these file systems. In this talk, I will describe my work on building a crash consistency testing framework designed specifically for PM file systems. I will present an overview of our testing approach and the bugs that the tool has found, and discuss the implications of these bugs on the development of PM file systems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Hayley LeBlanc is a second year PhD student at the University of Texas at Austin. She is interested in developing techniques and tools to make sure that storage systems are reliable and correct. She also enjoys fencing and volunteering at her local animal shelter.&lt;/p&gt;

&lt;h1 id=&#34;dec-3&#34;&gt;Dec. 3&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://sydgibs.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Sydney Gibson&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Efficient Verification of High-Performance Cryptographic Routines on New Hardware&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Formal proofs are often employed to show correctness of cryptographic routines at the assembly level, especially in instances where architecture-optimized performance is desirable or where compilers do not exist for the target ISA. While common cryptographic routines are often implemented in many different ISAs, the current cost of verification scales poorly with the number of architectures. In this talk, we explore solutions for writing correctness proofs for cryptographic routines which are generic across different architectures.&lt;/p&gt;

&lt;p&gt;Specifically, we will look at assembly implementations of an RSA signature verification routine in RISC-V and in the OpenTitan BigNumber Accelerator (OTBN) ISA. Despite dramatic differences in these two ISAs, we find that the high-level control flow structure of the RSA routine is quite similar across implementations. We use this observation to construct a framework for writing partial architecture-generic assembly-level proofs which are abstracted over hardware details (e.g., register width). We will discuss how this framework can be used to reduce the overhead of proving the correctness of common cryptographic routines on different architectures, and look to future possibilities for further reducing this overhead.~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Sydney is a second-year Ph.D. student in the Computer Science Department of Carnegie Mellon, advised by Bryan Parno. She is interested in formal techniques for verifying safety and security properties of low-level, high-performance systems at scale. Sydney received her B.S. and M.Eng. from MIT, where she worked on verification techniques for concurrent, crash-safe systems.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Spring 2021)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2021sp/</link>
      <pubDate>Sun, 21 Feb 2021 12:27:37 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2021sp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:15pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating students should register for the 2-credit course CSE 280O.&lt;/p&gt;

&lt;p&gt;For spring 2021, this seminar is completely virtual and will feature a mix of internal and external speakers.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-2&#34;&gt;April 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://research.aldrinmontana.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aldrin Montana&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Running the Trails of Data Management&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-9&#34;&gt;April 9&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://www.rntz.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Michael Arntzenius&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;PL design and programming by voice&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-16&#34;&gt;April 16&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Achilles Benetopoulos&lt;/td&gt;
&lt;td&gt;HARP: Eliminating Software Supply-Chain Vulnerabilities via Active Learning and Regeneration of String Processing Libraries&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-23&#34;&gt;April 23&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Konstantinos Kallas&lt;/td&gt;
&lt;td&gt;PaSh: A parallelizing shell&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-30&#34;&gt;April 30&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Eric Atkinson&lt;/td&gt;
&lt;td&gt;Programming and Reasoning with Partial Observability&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-7&#34;&gt;May 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Vadim Zaliva&lt;/td&gt;
&lt;td&gt;HELIX: From Math to Verified Code&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-14&#34;&gt;May 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.rochester.edu/u/bvalpey/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Benjamin Valpey&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Discovering the Semantics of NVIDIA&amp;rsquo;s SASS ISA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-21&#34;&gt;May 21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Zeeshan Lakhani&lt;/td&gt;
&lt;td&gt;Polarized Functional Programming v0.1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-28&#34;&gt;May 28&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Philippa Cowderoy&lt;/td&gt;
&lt;td&gt;Information Aware Type Systems and Telescopic Constraint Trees&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#june-4&#34;&gt;June 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Ranysha Ware&lt;/td&gt;
&lt;td&gt;Battle for Bandwidth: Evaluating Congestion Control Deployability For The Internet&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;april-2&#34;&gt;April 2&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://research.aldrinmontana.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aldrin Montana&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Running the Trails of Data Management&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The demise of Moore&amp;rsquo;s law and Dennard scaling have swung a pendulum back towards computational storage&amp;ndash;disk drives equipped with modest processors and working memory. As was the case when the earliest ``active drives&amp;rdquo; were developed over three decades ago, moving computational kernels closer to where the data is stored presents an opportunity to improve data processing and retrieval performance by alleviating bottlenecks at CPUs that can no longer promise exponential increases in performance over time. We explore this opportunity in a 3-way collaboration between industry and academia with the goal of showing the benefits provided by computational storage devices for scientific analysis workloads. The analysis workloads are based on use cases for the Human Cell Atlas (HCA) and the UCSC Genomics Institute, the computational storage devices are architected and designed by Seagate, and the system that brings these together is architected by our declarative programmable storage research group at UCSC. This talk uses trail running as a fun metaphor to detail the context and directions of our collaboration that spans data management, single-cell RNA sequencing, and a storage system that leverages computational storage devices.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Aldrin is a 3rd year PhD student at UC Santa Cruz advised by Peter Alvaro, but works extensively with Carlos Maltzahn (UCSC), Jeff LeFevre (UCSC), and Philip Kufeldt (Seagate). Aldrin received his B.S. and M.S. in computer science from Cal Poly, San Luis Obispo working with Alex Dekhtyar on a collaborative, microbial source tracking project with professors and students in the biology and biochemistry departments. Before joining UCSC’s PhD program, Aldrin has worked on data management of genomic variants at a biotech company, Personalis, Inc. His research interests are primarily in data management systems and bioinformatics, but also span programming languages, storage systems, and software engineering.&lt;/p&gt;

&lt;h1 id=&#34;april-9&#34;&gt;April 9&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;http://www.rntz.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Michael Arntzenius&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; PL design and programming by voice&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Many programmers and other computer users suffer from repetitive strain injuries (RSI) of the hand that make using a keyboard for extended periods painful. For some kinds of RSI, therapy or surgery may resolve the problem, but in recalcitrant cases sometimes the only option is to reduce or cease typing. So what does a programmer do if they can&amp;rsquo;t type?One option is to use your voice. Speech recognition technology has advanced by leaps and bounds over the past decade, but most people&amp;rsquo;s ideas about voice-driven UI are based on convenient but limited voice assistants like Siri or Alexa, or at best dictation or prose-writing tools. What does a voice interface for expert users look like? A small but growing community of programmers, many affected by RSI, have been developing and using tools that explore this question.I suffer from RSI and use a voice control tool called Talon to program, control my computer, and write my thesis; but I&amp;rsquo;m also a programming languages researcher, and so I find it natural to wonder: how might PL research intersect with voice control? In this talk, I&amp;rsquo;ll try my best to answer that question, as well as a few others:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;What is voice coding like?  What unique challenges does it present compared with keyboard coding?&lt;/li&gt;
&lt;li&gt;What can we learn from this about designing voice interfaces for expert users?  Specifically, how can programming languages better support voice coding?&lt;/li&gt;
&lt;li&gt;How does a voice control system work?  What does it have in common with PL implementation?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Depending on how you count, Michael Arntzenius is somewhere between a 4th- and a 9th-year PhD student. He works with Neel Krishnaswami on Datafun, an attempt to combine the bottom-up deductive query language Datalog with higher-order typed functional programming. He is interested in monotonicity as a unifying and simplifying theme in incremental, concurrent, and distributed computation; and generally in the theory, design, and implementation of programming systems.&lt;/p&gt;

&lt;h1 id=&#34;april-16&#34;&gt;April 16&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Achilles Benetopoulos&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; HARP: Eliminating Software Supply-Chain Vulnerabilities via Active Learning and Regeneration of String Processing Libraries&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Software supply-chain attacks are becoming an important security concern. These attacks focus on a dependency of the target rather than the target itself and often affect the target as well as other consumers of that dependency. We propose active library learning and regeneration (ALR) techniques for inferring and reconstructing the core functionality of a black-box software dependency. Using increasingly sophisticated rounds of exploration, ALR generates inputs, provides these inputs to the dependency, and observes the dependency’s outputs and interactions to infer a model of the dependency’s behavior captured in a domain-specific language. We present HARP, an ALR system for string processing dependencies. We apply HARP to successfully regenerate string-processing libraries in JavaScript, Python, and C/C++. In the majority of cases, HARP completes the regeneration in less than a minute, remains fully compatible with the original library, and achieves performance indistinguishable from the original library. We also demonstrate that HARP can eliminate vulnerabilities associated with libraries targeted in a number of highly visible security incidents of the JavaScript ecosystem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Achilles Benetopoulos is a backend software engineer at Plum Fintech. He received a Masters degree in Engineering from the National Technical University of Athens. He is interested in exploring better ways of building robust and performant distributed systems. Starting in the fall, he will be joining UC Santa Cruz as a graduate student advised by Peter Alvaro, to work towards this goal. When he gets too frustrated by computers, he cooks.&lt;/p&gt;

&lt;h1 id=&#34;april-23&#34;&gt;April 23&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Konstantinos Kallas&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; PaSh: A parallelizing shell&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk I will present PaSh, a new shell that exposes data parallelism in POSIX shell scripts. To achieve that, PaSh proposes: (i) an order-aware dataflow model that captures a fragment of the shell, (ii) a set of dataflow transformations that extract parallelism and have been proven to be correct, (iii) a lightweight framework that captures the correspondence of shell commands and order-aware dataflow nodes, and (iv) a just-in-time compilation framework that allows for effective compilation despite the dynamic nature of the shell. PaSh is open-source and you can try it out today here: &lt;a href=&#34;https://github.com/andromeda/pash&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/andromeda/pash&lt;/a&gt;. If you want to learn more about it you can read our paper that will appear in EuroSys 2021 (next week) here: &lt;a href=&#34;https://arxiv.org/abs/2007.09436&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://arxiv.org/abs/2007.09436&lt;/a&gt; and if you want to learn more about the dataflow model you can read the paper that introduces it and proves the correctness of the transformations here: &lt;a href=&#34;https://arxiv.org/abs/2012.15422&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://arxiv.org/abs/2012.15422&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Konstantinos Kallas is a 3rd year PhD student at the University of Pennsylvania working with Rajeev Alur. They are broadly interested in all things PL, distributed systems, and greek folk mountain music. Recently, together with Nikos Vasilakis and several other amazing people they have been working on invigorating the research on the shell. They are also working on partial order semantics for distributed stream processing and programming models for serverless. You can find more information about them here: &lt;a href=&#34;https://angelhof.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://angelhof.github.io/&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;april-30&#34;&gt;April 30&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Eric Atkinson&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Programming and Reasoning with Partial Observability&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Computer programs are increasingly being deployed in partially-observable environments. A partially-observable environment is an environment whose state is not completely visible to the program, but from which the program receives partial observations. Developers typically deal with partial observability by writing a &lt;em&gt;state estimator&lt;/em&gt; that, given observations, attempts to deduce the hidden state of the environment. In safety-critical domains, to formally verify safety properties developers may write an &lt;em&gt;environment model&lt;/em&gt;. The model captures the relationship between observations and hidden states and is used to prove the software correct.&lt;/p&gt;

&lt;p&gt;In my talk, I will present a new methodology for writing and verifying programs in partially observable environments. I will present &lt;em&gt;belief programming&lt;/em&gt;, a programming methodology where developers write an environment model that the program runtime automatically uses to perform state estimation. A belief program dynamically updates and queries a belief state that captures the possible states the environment could be in. To enable verification, I will present &lt;em&gt;Epistemic Hoare Logic&lt;/em&gt;, which reasons about the possible belief states of a belief program the same way that classical Hoare logic reasons about the possible states of a program. I will develop these concepts by explaining a semantics and a program logic for a simple core language called BLIMP. I will also discuss a case study in which we used BLIMP to implement a verified controller for the Mars Polar Lander, and I will evaluate the performance of a C implementation of BLIMP.&lt;/p&gt;

&lt;p&gt;Paper link: &lt;a href=&#34;https://dl.acm.org/doi/10.1145/3428268&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://dl.acm.org/doi/10.1145/3428268&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Eric Atkinson is a 6th year PhD student at MIT advised by Michael Carbin. His primary research interests involve using programming language tools to help developers manage both probabilistic and nondeterministic uncertainty.&lt;/p&gt;

&lt;h1 id=&#34;may-7&#34;&gt;May 7&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Vadim Zaliva&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; HELIX: From Math to Verified Code&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk we will presents HELIX, a code generation and formal
verification system with a focus on the intersection of
high-performance and high-assurance numerical computing. This allowed
us to build a system that could be fine-tuned to generate efficient
code for a broad set of computer architectures while providing formal
guarantees of such generated code&amp;rsquo;s correctness.&lt;/p&gt;

&lt;p&gt;The method we used for high-performance code synthesis is the
algebraic transformation of vector and matrix computations into a
dataflow optimized for parallel or vectorized processing on target
hardware. The abstraction used to formalize and verify this technique
is an operator language used with semantics-preserving
term-rewriting. We use sparse vector abstraction to represent partial
computations, enabling us to use algebraic reasoning to prove parallel
decomposition properties.&lt;/p&gt;

&lt;p&gt;HELIX provides a formal verification foundation for rewriting-based
algebraic code synthesis optimizations, driven by an external
oracle. Presently HELIX uses SPIRAL as an oracle deriving the rule
application order. The SPIRAL system was developed over the years and
successfully applied to generate code for various numeric
algorithms. Building on its sound algebraic foundation, we generalize
and extend it in the direction of non-linear operators, towards a new
theory of partial computations, applying formal language theory and
formal verification techniques.&lt;/p&gt;

&lt;p&gt;HELIX is developed and proven in Coq proof assistant and demonstrated
on a real-life example of verified high-performance code generation of
the dynamic window safety monitor for a cyber-physical robot system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Vadim Zaliva works on formal verifications of computer programs,
presently as a Senior Research Associate at Cambridge University and
previously as part of his Ph.D. at Carnegie Mellon University. His
diverse academic interests in addition to formal methods range from
computer security to machine learning and gesture recognition. With
20+ years of experience in the design and implementation of commercial
software, he has worked through the ranks of the software industry
from software engineer to CTO, CEO, and company founder.&lt;/p&gt;

&lt;h1 id=&#34;may-14&#34;&gt;May 14&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.rochester.edu/u/bvalpey/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Benjamin Valpey&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Discovering the Semantics of NVIDIA&amp;rsquo;s SASS ISA&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this work, we specify a formal semantics of NVIDIA&amp;rsquo;s SASS instruction set, the ISA that is actually executed by NVIDIA GPUs.  We introduce the ROCetta approach for discovering the semantics of a target language that requires the semantics a source language, and the ability to obtain a translation from the source to the target language.   Using this approach, we have discovered and verified the semantics of 421 SASS instructions.  In addition, our verification effort was able to uncover 18 bugs in the CUDA compiler&amp;rsquo;s translation of single-instruction PTX programs.  In some cases, bugs were only caught during verification and were missed by the testing framework, which lacked a test for inputs that trigger the bug. Furthermore, verification of 3,581 programs took 14 minutes when run in parallel, while running the full test suite against hardware took upwards of 30 minutes.  The low cost of verification, along with its superior ability to detect bugs, makes it an invaluable tool to detect bugs that occur in the translation of small programs.&lt;/p&gt;

&lt;h1 id=&#34;may-21&#34;&gt;May 21&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Zeeshan Lakhani&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Polarized Functional Programming v0.1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; When designing a new, real-world type system, where would you start? Looking for
examples, you may notice that a language like Typescript has a myriad of
advanced typing features, though they&amp;rsquo;re oriented toward trying to
capture JavaScript&amp;rsquo;s many dynamic idioms and (now) lengthy history of existing
programs. Furthermore, even with these advanced features, the language is not
sound, i.e. certain operations cannot be known to be type-safe at compile-time.
Looking elsewhere, like in the ML family of languages, you&amp;rsquo;ll see a powerful
type inference mechanism helping to free programmers from the burden of
numerous, explicit type annotations. Yet, as new research-driven type extensions
have been incorporated, the need for explicit annotations or pre-processing
steps has increased in certain situations. As the complexity of our programs and
the properties about them that we&amp;rsquo;d like to statically guarantee grow, how far
can just typechecking take us while remaining sound and without us having to
associate proofs with our programs?&lt;/p&gt;

&lt;p&gt;The answer is pretty far. Lightweight verification through refinement types is
catching on. Most &lt;em&gt;modern&lt;/em&gt; languages, e.g. Rust, OCaml, Dotty/Scala, come out of
the box with sum types or enumerated variants and integrations for extended
static code analysis. Our answer to these questions lies in the powerful
relationship between static analysis and type theory and how to treat evaluation
(essentially, eager versus lazy) as first-class.&lt;/p&gt;

&lt;p&gt;In this talk, I will present our work-in-progress research on a polarized
functional programming language based on the call-by-push-value (CBPV)
λ-calculus, which allows for the mixing of both call-by-name and call-by-value
evaluation inside of a single program via a kind-like operator, shifting between
positive and negative types. We extend this polarized calculus further with a
transparent and equirecursive interpretation of mixed-inductive-and-coinductive datatypes,
allowing us to leverage strong structural subtyping and datasort refinements over sums and
intersections. Additionally, typechecking works bidirectionally in our system,
meaning that terms can be checked to a certain type or synthesized as a
certain type, which scales well for adding various expressive type features to
our language.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Zeeshan is the founder of Papers We Love and PWLConf, as well as an organizer. He&amp;rsquo;s also
the Director of Research and Development at BlockFi working on various data and program
analysis projects. And, he&amp;rsquo;s a PhD student at Carnegie Mellon University&amp;rsquo;s School of
Computer Science, studying Programming Languages under Frank Pfenning.&lt;/p&gt;

&lt;h1 id=&#34;may-28&#34;&gt;May 28&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Philippa Cowderoy&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Information Aware Type Systems and Telescopic Constraint Trees&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; What does conservation of information have to do with type systems? Are type checkers specialised operating systems? Can we understand dataflow in type systems or are we doomed to drown in it?&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll present a highly familiar type system in pursuit of an `Information Aware&amp;rsquo; style, using information effects to reveal data flow and help in implementing a checker. I also calculate a general, scoped, constraint-based representation of typechecking problems from the typing rules.&lt;/p&gt;

&lt;p&gt;And then, because why not? Let&amp;rsquo;s toy with substructural systems and maybe even incremental checking!&lt;/p&gt;

&lt;p&gt;Warning: talk may contain willfully creative use of long-standing concepts&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Philippa Cowderoy is a professional procrastinator and amateur computer scientist, having dropped out of the University of Nottingham as an undergraduate in 2007.&lt;/p&gt;

&lt;p&gt;Somehow this still hasn&amp;rsquo;t put her off being frustrated with her tools on a increasingly deeper level. When she is bored enough, she is now mining particularly meta veins of frustration shared by others in the PL community.&lt;/p&gt;

&lt;p&gt;In her copious free (if not high-quality) time she plays too many games and spends too little time around cats.&lt;/p&gt;

&lt;h1 id=&#34;june-4&#34;&gt;June 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Ranysha Ware&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Battle for Bandwidth: Evaluating Congestion Control Deployability For The Internet&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The stability of the Internet relies on congestion control algorithms (CCAs) to efficiently and fairly share limited network resources. Dozens of congestion control algorithms have been proposed in the past 30 years, however, we still lack a good way to decide whether a new algorithm is reasonable to deploy on the Internet. As we will show in this talk, new algorithms can be dramatically unfair to widely-deployed legacy algorithms. For example, we prove that Google&amp;rsquo;s new CCA, BBR, will always consume a fixed fraction of the link when competing with any number of Cubic flows.&lt;/p&gt;

&lt;p&gt;Given the threat of poor performance due to competing heterogeneous CCAs, in this talk we discuss considerations for deploying new CCAs on the Internet. While past efforts have focused on achieving fairness or friendliness between new algorithms and legacy algorithms, we instead advocate for an approach centered on quantifying and limiting harm caused by the new algorithm on the status quo. We argue that a harm-based approach is more practical, more future proof, and handles a wider range of quality metrics than traditional notions of fairness and friendliness.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt;  Ranysha Ware is a PhD student in Carnegie Mellon University’s Computer Science Department, co-advised by Professor Justine Sherry and Professor Srinivasan Seshan. Her bailiwick is computer networking. Her current research focuses on challenges arising from the deployment of new transport protocols and congestion control algorithms in the Internet. Ranysha earned her M.S. (2015) from UMass Amherst and B.S (2013) from SUNY New Paltz. She is a recipient of the IRTF Applied Networking Research Prize, Facebook Emerging Scholar Award, and National GEM Consortium Fellowship.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Winter 2021)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2021wi/</link>
      <pubDate>Sat, 02 Jan 2021 21:45:29 -0800</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2021wi/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:15pm (PT) &lt;br/&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet &lt;br/&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating students should register for the 2-credit course CSE 280O.&lt;/p&gt;

&lt;p&gt;For winter 2021, this seminar is completely virtual and will feature a mix of internal and external speakers.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-8&#34;&gt;Jan. 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Introductions and social time&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-15&#34;&gt;Jan. 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://very.science/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kenny Foner&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Dialectic: Pragmatic, Efficient Session Types for Async Rust&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-22&#34;&gt;Jan. 22&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.princeton.edu/~nhossain/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Naorin Hossain&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;TransForm: Formally Specifying Transistency Models and Synthesizing Enhanced Litmus Tests&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-29&#34;&gt;Jan. 29&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://aviral.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aviral Goel&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;On the Design, Implementation, and Use of Laziness in R&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-5&#34;&gt;Feb. 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.victoraying.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Victor Ying&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Parallelizing Sequential Code with Compiler-Hardware Co-Design&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-12&#34;&gt;Feb. 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://koronkevi.ch/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Paulette Koronkevich&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;The ANF Translation Preserves Dependent Types up to Extensional Equality&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-19&#34;&gt;Feb. 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Kamala Ramasubramanian&lt;/td&gt;
&lt;td&gt;ACT now: Aggregate Comparison of Traces for Incident Localization&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-26&#34;&gt;Feb. 26&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://prakashmurali.bitbucket.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Prakash Murali&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Closing the Gap between Quantum Algorithms and Hardware using Compilation and Architecture&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-5&#34;&gt;March 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.vinujoseph.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Vinu Joseph&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Programmable Neural Network Compression with Correctness Emphasis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-12&#34;&gt;March 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Daniel Bittman&lt;/td&gt;
&lt;td&gt;Twizzler: Evolving Operating Systems for Non-volatile Memory&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;jan-8&#34;&gt;Jan. 8&lt;/h1&gt;

&lt;p&gt;Introductions and social time&lt;/p&gt;

&lt;h1 id=&#34;jan-15&#34;&gt;Jan. 15&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://very.science/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kenny Foner&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Dialectic: Pragmatic, Efficient Session Types for Async Rust&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Session types have long promised the ability to enforce complex temporal invariants about message ordering in distributed systems, guaranteeing that a well-session-typed program always correctly follows a messaging protocol to its end. Despite their potential, these type systems have seen relatively little adoption in the mainstream. In part, this is due to their inherent reliance on linear typing, a feature not present and difficult to emulate in most popular languages. Recently, this has changed with the emergence of Rust, a systems programming language built atop a flexible &amp;ldquo;ownership type system&amp;rdquo; to track reference aliasing. Although Rust enforces in actuality a form of affine typing (weaker than the linear typing most formal session-typed calculi require) it&amp;rsquo;s enough to build a library for session types that statically enforces the slightly-weaker guarantee that a program correctly follows a messaging protocol so long as it is running, but may quit the session early. Of course, this is the best we can hope to get in the real world! Networks go down, computers crash, and hardware just plain breaks. For session types to be broadly adopted, they must survive contact with this real and unpredictable world—and equally, with the real and unpredictable people who want to use them in their programs.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve just released version 0.2 of &lt;a href=&#34;https://docs.rs/dialectic&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Dialectic&lt;/a&gt;: a library for pragmatic, succinct, efficient session types in Rust. Dialectic embraces Rust&amp;rsquo;s burgeoning ecosystem of high-performance async networking by being polymorphic over any backend transport used to convey messages between parties. Unlike many libraries for session types, Dialectic assumes that the other party might break protocol or disconnect at any time, and is designed to gracefully handle such failures without compromising type safety.  Dialectic is designed to be used for writing specifications and programs of every size from small to large, and provides what&amp;rsquo;s needed to write modular specifications and implementations of complex protocols—and not merely the regular session types expressible in most libraries, but all context-free session types.&lt;/p&gt;

&lt;p&gt;More than merely showing off this cool thing I&amp;rsquo;m working on, I want to talk about the design process that went into making it. Designing a programming paradigm—whether you want to call it an embedded domain-specific language or merely a library—is a multi-faceted puzzle spanning considerations from psychological familiarity to formal computability. My hope is that in walking through this case study in embedded language design, we can spark more thoughts about how we as PL researchers can play in this field together and design beautiful, useful tools.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kenny Foner (kwf@very.science) is a senior software engineer at Bolt Labs working on privacy-preserving financial technology for everyone. They have a master&amp;rsquo;s degree in programming languages from the University of Pennsylvania, where they worked on a smorgasbord of fun things from laziness to random testing. When they&amp;rsquo;re not writing Rust, they&amp;rsquo;re usually somewhere in the forest.&lt;/p&gt;

&lt;h1 id=&#34;jan-22&#34;&gt;Jan. 22&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.princeton.edu/~nhossain/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Naorin Hossain&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; TransForm: Formally Specifying Transistency Models and Synthesizing Enhanced Litmus Tests&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Memory consistency models (MCMs) have been formulated as a mechanism for expressing the legal ordering and visibility of shared memory accesses in hardware and software. They are fundamental for ensuring heterogeneous components of a system execute and interact as expected to prevent hardware-induced bugs in real-world programs. However, ISA-level MCMs are limited to defining the behavior of only user-facing assembly instructions and do not account for virtual memory implementations that may result in the execution of 1) hardware-level state updates and 2) system-level interactions. Both are capable of accessing memory and may affect program outcomes, thus making them software-visible. As a result, memory transistency models (MTMs) have been coined as a superset of MCMs to additionally capture and enforce virtual memory-aware ordering rules. However, no prior work enabled the formal specification or analysis of MTMs.&lt;/p&gt;

&lt;p&gt;TransForm fills this gap by introducing an axiomatic vocabulary for formally specifying MTMs that builds on the standard axiomatic vocabulary traditionally used for describing MCMs. It provides new constructs for modeling transistency-specific features such as hardware-level state updates and system-level interactions. Using this new axiomatic vocabulary, MTMs can be formally specified and used with TransForm’s synthesis engine to synthesize litmus tests enhanced with transistency features, called enhanced litmus tests. This talk will cover TransForm’s axiomatic vocabulary and synthesis engine, as well as a case study performed with TransForm to formally define an approximate MTM for Intel x86 processors.&lt;/p&gt;

&lt;h1 id=&#34;jan-29&#34;&gt;Jan. 29&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;http://aviral.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aviral Goel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; On the Design, Implementation, and Use of Laziness in R&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk, I will present the design and implementation of call-by-need in R, and a data-driven study of how generations of programmers have put laziness to use in their code. In our study, we analyze 16,707 R packages and observe the creation of 270.9 B promises. Our data suggest that there is little supporting evidence to assert that programmers use laziness to avoid unnecessary computation or to operate over infinite data structures. For the most part R code appears to have been written without reliance on and in many cases even knowledge of, delayed argument evaluation. The only significant exception is a small number of packages which leverage call-by-need for meta-programming. I will discuss how we intend to leverage these insights to remove laziness from R and enable non-intrusive migration of code from lazy to eager evaluation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Aviral Goel is a Computer Science Ph.D. student at Northeastern University, advised by Professor Jan Vitek. He received his Bachelor&amp;rsquo;s degree in Electronics and Communication Engineering from Netaji Subhas Institute of Technology, India.&lt;/p&gt;

&lt;p&gt;He is interested in improving tools and techniques for data science applications. He is enabling R programmers to write faster and bug-free code by migrating the language from lazy-by-default to lazy-on-demand semantics.&lt;/p&gt;

&lt;p&gt;He is also involved in the development of a type system for R.&lt;/p&gt;

&lt;h1 id=&#34;feb-5&#34;&gt;Feb. 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.victoraying.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Victor Ying&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Parallelizing Sequential Code with Compiler-Hardware Co-Design&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Today, most code still runs on expensive, power-hungry processors that prioritize single-thread performance. Speculative parallelization is an enticing approach to accelerate computation while retaining the ease of sequential programming, by launching tasks in parallel before knowing if they are independent. Unfortunately, prior speculative parallelizing compilers and architectures achieved limited speedups due to high costs of recovering from misspeculation and hardware scalability bottlenecks.&lt;/p&gt;

&lt;p&gt;We present T4, a parallelizing compiler that executes sequential programs as trees of tiny timestamped tasks. T4 targets the recent Swarm architecture, which presents new opportunities and challenges for automatic parallelization. T4 introduces novel compiler techniques to expose parallelism aggressively across the entire program, breaking applications into tiny tasks of tens of instructions each. Task trees unfold their branches in parallel to enable high task-spawn throughput while exploiting selective aborts to recover from misspeculation cheaply. T4 exploits parallelism across function calls, loops, and loop nests; performs new transformations to reduce task spawn costs and avoid false sharing; and exploits data locality among fine-grain tasks. As a result, T4 scales several hard-to-parallelize SPEC CPU2006 benchmarks to tens of cores, where prior work attained little or no speedup.&lt;/p&gt;

&lt;p&gt;For more information, please visit &lt;a href=&#34;swarm.csail.mit.edu&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;swarm.csail.mit.edu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Victor Ying is a 5th year PhD student at MIT, advised by Daniel Sanchez. He works on parallel architectures, compilers, and programming models. Victor&amp;rsquo;s recent work focuses on redesigning abstractions between hardware and software to make it as easy to exploit multicore parallelism as it is to write ordinary sequential programs. His prior work includes Boolean satisfiability solvers, scheduling machine learning workloads on hardware accelerators, and embedded and distributed systems.&lt;/p&gt;

&lt;h1 id=&#34;feb-12&#34;&gt;Feb. 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://koronkevi.ch/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Paulette Koronkevich&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; The ANF Translation Preserves Dependent Types up to Extensional Equality&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Many programmers use dependently-typed languages like Coq to
machine-verify high-assurance software. However, existing compilers for
these languages provide no guarantees after compiling, nor when linking
after compilation. Type-preserving compilers preserve guarantees encoded
in types, then use type checking to verify compiled code and ensure safe
linking with external code. Unfortunately, dependent type systems are
highly sensitive to syntactic changes, including compilation, so
preserving them through a compiler pass is difficult.&lt;/p&gt;

&lt;p&gt;In this talk, I will present some examples of why dependent typing is
difficult to preserve through simple syntactic changes. I will also
present our solution to preserving dependent types through the ANF
translation, a necessary transformation towards compiling a functional
language down to machine code. Our ANF translation preserves dependent
types, provided that the target type system has a way to encode these
syntactic semantics-preserving changes. We encode these by including
extensional equality in our target type system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Paulette Koronkevich is a second year graduate student (finishing
MSc and starting PhD) at the University of British Columbia, working
with William J. Bowman. She has a undergraduate degree in computer
science from Indiana University. Her interests include compilers, cats,
and cooking.&lt;/p&gt;

&lt;h1 id=&#34;feb-19&#34;&gt;Feb. 19&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Kamala Ramasubramanian&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; ACT now: Aggregate Comparison of Traces for Incident Localization&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Incidents in production systems are common and downtime is expensive. Applying an appropriate mitigating action quickly, such as changing a specific firewall rule or routing around a broken network link, saves money. Identifying where to mitigate is time-consuming since a single failure can produce widespread effects. Knowing how different system events relate to each other is necessary to quickly identify where to mitigate. Our approach, Aggregate Comparison of Traces (ACT), localizes incidents by comparing sets of traces (which capture events and their relationships for individual requests) sampled from the most recent steady-state operation and during an incident. In our quantitative experiments, we conduct hundreds of simulations and show that ACT is able to identify exactly where to mitigate in all but a few cases.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kamala Ramasubramanian is a PhD candidate at University of California, Santa Cruz advised by Peter Alvaro. She works on understanding, implementing and troubleshooting distributed systems by reasoning about observed system executions. She recently became interested in system verification and how it may overlap with her current work. She is a vegetarian foodie, likes to CrossFit and wants to try surfing.&lt;/p&gt;

&lt;h1 id=&#34;feb-26&#34;&gt;Feb. 26&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://prakashmurali.bitbucket.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Prakash Murali&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Closing the Gap between Quantum Algorithms and Hardware using Compilation and Architecture&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In recent years, quantum computing (QC) hardware has progressed considerably with small systems being prototyped by industry and academic vendors. However, there is a huge gap between the resource requirements of promising applications and the hardware that is buildable now; qubit counts and operational noise constraints of applications exceed hardware capabilities by 5-6 orders of magnitude. Our work seeks to enable practical QC by bridging this gap: from the top with novel compiler techniques and algorithmic optimizations to reduce application requirements and from the bottom via system architectures efficiently exploiting scarce QC resources.&lt;/p&gt;

&lt;p&gt;In this talk, we present two cross-cutting optimizations that narrow the applications-to-hardware resource gap. First, we present noise-adaptive compilation techniques that optimize applications for the spatio-temporal noise variations seen in real QC systems. Using real executions, we demonstrate average fidelity improvements of 3X using noise-adaptivity, compared to industry compiler tools. Second, on the architecture front, we study instruction set design issues considering application requirements and hardware gate calibration overheads. Current QC systems either use ISAs with a single two-qubit gate type or families of continuous gate sets. Using architectural simulations based on Google and Rigetti hardware, we show that QC instruction sets with 4-8 two-qubit gate types are best suited for expressing application requirements, while incurring tractable calibration overheads. In response to our work, several industry vendors have included noise-adaptivity and its extensions as part of their toolflows and adjusted device architecture to expose more native operations and hardware characterization data.&lt;/p&gt;

&lt;h1 id=&#34;march-5&#34;&gt;March 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Vinu Joseph&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Programmable Neural Network Compression with Correctness Emphasis&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Deep neural networks (DNNs) frequently contain far more weights, represented at higher precision, than are required for the specific task which they are trained to perform.
Consequently, they can often be compressed using techniques such as weight pruning and quantization that reduce both the model size and inference time without appreciable loss in accuracy.
However, finding the best compression strategy and corresponding target sparsity for a given DNN, hardware platform, and optimization objective currently requires expensive, frequently manual, trial-and-error experimentation.
In this talk, we introduce a programmable system for model compression called Condensa. Users programmatically compose simple operators, in Python, to build more complex and practically interesting compression strategies.
Given a strategy and user-provided objective (such as minimization of running time), Condensa uses a novel Bayesian optimization-based algorithm to automatically infer desirable sparsities.
Our experiments real-world DNNs demonstrate memory footprint and hardware runtime throughput improvements of 188x and 2.59x, respectively, using at most ten samples per search.
We have released a reference implementation of &lt;a href=&#34;https://github.com/NVlabs/condensa&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Condensa&lt;/a&gt;. Next, we will talk about our recent correctness extension where we preserve not just the overall accuracy but also metrics relating to model fairness and interpretability.
To achieve this, we augment the compression loss function with terms arising from the teacher-student learning paradigm and show how to automatically tune the associated parameters.
We demonstrate the effectiveness of our approach on multiple compression schemes and accuracy recovery algorithms using several different real-world network architectures.
We obtain a significant reduction of up to 4.1X in the number of mismatches between the compressed and reference models, while also achieving a significant reduction in class-wise disparate impact metrics compared to the reference models.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Vinu Joseph is a Ph.D. candidate in Computer Science at the School of Computing at the University of Utah, Salt Lake City, working on efficient deep learning computing, robustness, and security of deep learning algorithms, advised by Prof. Ganesh Gopalakrishnan.
He is one of the five recipients of the NVIDIA Graduate fellowship, the recipients were selected based on their academic achievements and area of research.
Prior to graduate studies, Vinu worked at ARM Inc. During his tenure at ARM, he was a recipient of the Bravo award for developing the programmer’s model for verifying real-time (‘R’) profile architecture which provides high-performing processors for safety-critical environments.
Vinu’s current research focuses on optimizing deep neural network-based systems for performance and scalability. More broadly, His research is at the intersection of systems, programming languages, and machine learning, to create a more efficient, performant, secure, privacy-preserving, and correct software.
His Ph.D. research has been mainly focused on deep neural network compression for resource-efficient inference and robustness. He is generously supported by an NVIDIA Ph.D. fellowship, mentored by Saurav Muralidharan and Michael Garland, he developed Condensa: A Programming System for Model Compression and Optimization.&lt;/p&gt;

&lt;h1 id=&#34;march-12&#34;&gt;March 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Daniel Bittman&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Twizzler: Evolving Operating Systems for Non-volatile Memory&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Byte addressable, non-volatile memory (NVM) demands that we rethink the entire system stack. Twizzler is an operating system designed for the near-future of NVM on the memory bus. It removes the kernel from the I/O path, provides programs with direct access to NVM, enabling simpler and more efficient long-term operations on persistent data. Twizzler provides a clean-slate programming model for persistent data, realizing the vision of Unix in a world of NVM. It does this through a pervasive notion of data identity coupled with an efficient design for persistent pointers that allows programmers to construct persistent data structures in a large, persistent, global address space. This talk will present an overview of Twizzler and discuss upcoming directions for Twizzler in security, distribution, and programming languages.Bio&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Daniel is a PhD candidate at UC Santa Cruz, advised by Ethan Miller and Peter Alvaro. His interests are in kernel programming and design, security, non-volatile memory, and concurrent programming. His current project is on developing an operating system for non-volatile memories and developing operating system designs and interfaces for better programming and data models in such an environment.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Fall 2020)</title>
      <link>http://lsd.ucsc.edu/lsd-seminar/2020fa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lsd.ucsc.edu/lsd-seminar/2020fa/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:15pm (PT)&lt;br/&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet &lt;br/&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br/&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating students should register for the 2-credit course CSE 280O.&lt;/p&gt;

&lt;p&gt;For fall 2020, this seminar is completely virtual.  We are excited to welcome a roster of external speakers from around the world!&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-2&#34;&gt;Oct. 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Social event and class introduction&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-9&#34;&gt;Oct. 9&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://mpg.is/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Matthías Páll Gissurarson&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Weakening Type Systems for Faster Prototyping&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-16&#34;&gt;Oct. 16&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://wen.works/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Wen Kokke&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;An introduction to Session Types&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-23&#34;&gt;Oct. 23&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kalevalp.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kalev Alpernas&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Correct and Secure Serverless Computing&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-30&#34;&gt;Oct. 30&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://software-lab.org/people/Daniel_Lehmann.html&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Daniel Lehmann&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Everything Old is New Again: Binary Security of WebAssembly&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-6&#34;&gt;Nov. 6&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://umazalakain.info/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Uma Zalakain&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Mechanising the Linear π-Calculus&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-13&#34;&gt;Nov. 13&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.cmu.edu/~kqy/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Katherine Ye&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Penrose: from mathematical notation to beautiful diagrams&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-20&#34;&gt;Nov. 20&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/lehigh.edu/jacobnelson/home&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jacob Nelson&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Bundled References: An Abstraction for Highly-Concurrent Linearizable Range Queries&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-4&#34;&gt;Dec. 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.cornell.edu/~avh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Alexa VanHattum&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Vectorization for Digital Signal Processors via Equality Saturation&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-11&#34;&gt;Dec. 11&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cis.upenn.edu/~euisuny/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Irene Yoon&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Modular, compositional, and executable semantics for LLVM IR&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;oct-2&#34;&gt;Oct. 2&lt;/h1&gt;

&lt;p&gt;Class introduction&lt;/p&gt;

&lt;h1 id=&#34;oct-9&#34;&gt;Oct. 9&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://mpg.is/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Matthías Páll Gissurarson&lt;/a&gt; (&lt;em&gt;Chalmers University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Weakening Type Systems for Faster Prototyping&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Types and type systems are great to provide the compiler with a partial specification of our programs, but it can often be tricky to write code that matches said specification. In this talk, I will demonstrate how we can allow developers to opt-in to a weaker type system &amp;ldquo;just get it to compile&amp;rdquo;, and what we can do to &amp;ldquo;fix&amp;rdquo; the code during compilation so that it matches the specification provided using synthesis and coercions, and hint to the developer what the issue is and how they might fix it.&lt;/p&gt;

&lt;h1 id=&#34;oct-16&#34;&gt;Oct. 16&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://wen.works/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Wen Kokke&lt;/a&gt; (&lt;em&gt;University of Edinburgh&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; An introduction to Session Types&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Much like the λ-calculus is the foundational calculus for functions, the π-calculus is the foundational calculus for message-passing concurrency. Both are terrifyingly powerful, in the sense that if you can compute something, you can do it using these languages. They&amp;rsquo;re also very scary, in the sense that you can easily write functions that &amp;ldquo;go wrong&amp;rdquo;, e.g., by getting different kinds of data mixed up, looping forever, or just getting stuck. In this talk, I&amp;rsquo;ll introduce the fundamentals of the π-calculus, and the continued effort to tame its potential for going wrong, while leaving as much of its power as possible intact. I&amp;rsquo;ll do all of this by analogy to the λ-calculus, and I&amp;rsquo;ll finish up by talk about concurrent λ-calculus—basically the answer to the question &amp;ldquo;What do I get if I smash my λs and πs together really hard?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;(The talk starts with a brief recap of the relevant bits of the untyped and simply-typed λ-calculus, just in case you could use a refresher.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Wen is a programming languages researcher at the University of Edinburgh, where she works on session types. She is also a researcher at Heriot-Watt University, where she works on lightweight verification for neural networks. In her spare time, she enjoys cooking and runs a small art space.&lt;/p&gt;

&lt;h1 id=&#34;oct-23&#34;&gt;Oct. 23&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://kalevalp.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kalev Alpernas&lt;/a&gt; (&lt;em&gt;Tel Aviv University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Correct and Secure Serverless Computing&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Serverless computing is a popular cloud computing paradigm that allows for easy deployment, rapid prototyping,
 and effortless, near-unlimited scalability. However, serverless computing can provide these benefits by introducing several restrictions and limitations on cloud applications, including limiting task execution time, requiring the use of ephemeral execution
 environments, and requiring that programs adopt an event-driven programming model. These limitations make it harder to write correct and secure applications.&lt;/p&gt;

&lt;p&gt;In this talk I will present two projects aimed at bridging these security and correctness gaps. The first—Trapeze—is
 a runtime IFC system that guarantees termination-sensitive non-interference,
 ensuring that sensitive data never leaks from a serverless application. The second—Watchtower—is a runtime monitoring system that checks for violation of arbitrary temporal correctness properties that cross-cut the entire application reporting to the user
 when violations occur. Watchtower also includes a record-and-replay component for locally reproducing and debugging property violations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kalev is a 4th year PhD candidate at Tel Aviv University, under the supervision of Prof. Mooly Sagiv. His
 research interests are in the intersection of serverless computing and PL/formal methods.&lt;/p&gt;

&lt;h1 id=&#34;oct-30&#34;&gt;Oct. 30&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;http://software-lab.org/people/Daniel_Lehmann.html&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Daniel Lehmann&lt;/a&gt; (&lt;em&gt;University of Stuttgart&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Everything Old is New Again: Binary Security of WebAssembly&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; WebAssembly is an increasingly popular, low-level binary format designed
to run code in browsers and on other platforms safely and securely, by
strictly separating code and data, enforcing types, and limiting
indirect control flow. Still, vulnerabilities in memory-unsafe source
languages can translate to vulnerabilities in WebAssembly binaries. We
have analyzed to what extent vulnerabilities are exploitable in
WebAssembly binaries, and how this compares to native code. We find that
many classic vulnerabilities which, due to common mitigations, are no
longer exploitable in native binaries, are completely exposed in
WebAssembly. Moreover, WebAssembly enables unique attacks, such as
overwriting supposedly constant data or manipulating the heap using a
stack overflow. In this talk, we will explain several attack primitives
that allow an attacker (i) to write arbitrary memory, (ii) to overwrite
sensitive data, and (iii) to trigger unexpected behavior by diverting
control flow or manipulating the host environment. This can ultimately
lead to new forms of cross-site scripting in the browser or remote code
execution on Node.js. We will also demonstrate one of our three
end-to-end exploits, which cover three different WebAssembly platforms.
In our quantitative evaluation of real-world WebAssembly binaries, we
also measure how likely our attack primitives are feasible in practice.
Overall, our findings show a perhaps surprising lack of binary security
in WebAssembly. Finally, we will discuss some potential mitigations and
give recommendations on how to harden WebAssembly binaries in the future.&lt;/p&gt;

&lt;h1 id=&#34;nov-6&#34;&gt;Nov. 6&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://umazalakain.info/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Uma Zalakain&lt;/a&gt; (&lt;em&gt;University of Glasgow&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Mechanising the Linear π-Calculus&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The π-calculus is a computational model for communication and concurrency. The
linear π-calculus restricts the π-calculus by demanding that every communication
channel is used exactly once. This results in more fine grained control over
communication, avoids race conditions, and is in itself enough to serve as a
target language to which the session-typed π-calculus can be compiled to.&lt;/p&gt;

&lt;p&gt;This talk will focus on mechanizing the linear π-calculus. I will first present
a mechanized syntax and an operational semantics for the untyped π-calculus. On
top of that, I will use leftover typing to define a resource-aware type system
that is parametrized by a set of usage coalgebras. I will compare this type
system with its more traditional alternative, and comment on some of its type
safety properties.&lt;/p&gt;

&lt;p&gt;Finally, I will briefly introduce some of our ongoing research, which aims to
mechanize the decidable typechecking of the linear π-calculus. We do so by
borrowing ideas from co-contextual type checking algorithms and applying them to
the linear π-calculus. This results in a constraint satisfaction problem that,
when satisfied, returns type substitutions that can be used to mechanically
build typing derivations for terms.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Uma is a 2nd year PhD student at the University of Glasgow, where she works on the machine verification of typed process calculi under the supervision of Dr Ornela Dardha.
On her spare time she enjoys going out along the local riverbank for a run, and she uses every opportunity she has to hike through the Italian Alps and the Basque Pyrenees.&lt;/p&gt;

&lt;h1 id=&#34;nov-13&#34;&gt;Nov. 13&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.cmu.edu/~kqy/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Katherine Ye&lt;/a&gt; (&lt;em&gt;Carnegie Mellon University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Penrose: from mathematical notation to beautiful diagrams&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; How do you design a system for automatically visualizing mathematics? In this talk I will discuss the approach taken in our SIGGRAPH 2020 paper to build a tool, called Penrose, for creating mathematical diagrams.&lt;/p&gt;

&lt;p&gt;The basic functionality of Penrose is to translate abstract statements written in familiar math-like notation into one or more possible visual representations. Rather than rely on a fixed library of visualization tools, the visual representation is user-defined in a constraint-based specification language; diagrams are then generated automatically via constrained numerical optimization. The system is user-extensible to many domains of mathematics, and is fast enough for iterative design exploration. In contrast to tools that specify diagrams via direct manipulation or low-level graphics programming, Penrose enables rapid creation and exploration of diagrams that faithfully preserve the underlying mathematical meaning. We demonstrate the effectiveness and generality of the system by showing how it can be used to illustrate a diverse set of concepts from mathematics and computer graphics.&lt;/p&gt;

&lt;p&gt;For more information (and pictures!), please see our paper page:
&lt;a href=&#34;https://penrose.ink/siggraph20&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://penrose.ink/siggraph20&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;nov-20&#34;&gt;Nov. 20&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://sites.google.com/lehigh.edu/jacobnelson/home&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jacob Nelson&lt;/a&gt; (&lt;em&gt;Lehigh University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Bundled References: An Abstraction for Highly-Concurrent Linearizable Range Queries&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; As the name suggests, range queries provide the capability to return all values of a set, whose keys are contained in a given range. In a concurrent setting, this particular operation presents challenges since it can be long running. To offer linearizable range queries, we must ensure that the operations observe a consistent snapshot of the data structure even in the midst of ongoing point operations (i.e. get, put and delete). Bundled references are a new building block to provide linearizable range query operations for highly concurrent linked data structures. At its core, a bundled reference maintains the history of a given data structure link to allow range queries to traverse a path through the data structure corresponding to a particular moment in time. By traversing only links that were &amp;ldquo;alive&amp;rdquo; at the range queries outset, a range query observes a view of the data structure that is consistent with the target atomic snapshot and is made of the minimal amount of nodes that should be accessed to preserve linearizability.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Jacob Nelson is a third-year PhD student at Lehigh University in Bethlehem, PA. His interests encompass a wide range of systems topics including highly concurrent data structures and distribution using remote direct memory access (RDMA). His most recent work is focused on how to leverage high performance one-sided RDMA operations to build a data-movement oriented transactional key-value store. Check out his &lt;a href=&#34;https://sites.google.com/lehigh.edu/jacobnelson&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;website&lt;/a&gt; for more info!&lt;/p&gt;

&lt;h1 id=&#34;dec-4&#34;&gt;Dec. 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.cornell.edu/~avh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Alexa VanHattum&lt;/a&gt; (&lt;em&gt;Cornell University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Vectorization for Digital Signal Processors via Equality Saturation&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Compute-heavy embedded systems, from augmented reality to 5G networking, rely on specialized hardware in the form of digital signal processors (DSPs). However, DSPs are designed to prioritize energy efficiency and predictability over programmability, with simple in-order architectures that offer little hardware-provided parallelism. Existing auto-vectorizing compilers can struggle to optimize small linear algebra kernels that rely on complex data movements. An expert can reach state-of-the-art performance by hand-writing specialized implementations to use vector instructions, but they must repeat this manual effort for each size instance. In this talk, I will describe Diospyros, a search-based compiler that automates this task of finding efficient vectorizations for smaller linear algebra kernels. Diospyros combines two automated reasoning techniques, symbolic evaluation and equality saturation over rewrite rules, to vectorize computations with irregular structure. We show that Diospyros outperforms DSP libraries by 2.8x on average and demonstrate how search-based techniques can help users reach performance competitive with expert tuning with less manual effort.&lt;/p&gt;

&lt;h1 id=&#34;dec-11&#34;&gt;Dec. 11&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cis.upenn.edu/~euisuny/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Irene Yoon&lt;/a&gt; (&lt;em&gt;University of Pennsylvania&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Modular, compositional, and executable semantics for LLVM IR&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The LLVM framework has been a long-time favorite for compiler enthusiasts. It is both a widely used industrial-strength compiler (most recognizably, Apple’s latest macOS and iOS development tools) and a popular research tool (winning the ACM Software Systems Award in 2012).&lt;/p&gt;

&lt;p&gt;How do we best ensure that LLVM-based tools (compilers, optimizers, code instrumentation passes, etc.) do what they’re supposed to — especially for safety- or security-critical applications?&lt;/p&gt;

&lt;p&gt;This talk is an introduction to a novel formal semantics for a large, sequential subset of the LLVM IR, mechanized in the Coq proof assistant. We will see how the use of modern semantic reasoning techniques allow us to write a &lt;em&gt;compositional, modular, and executable&lt;/em&gt; semantics. In particular, I will discuss how the development of an &lt;em&gt;interaction tree&lt;/em&gt;-based semantics gives us (1) expressive combinators for defining compositional semantics, (2) a modular separation of concerns for effects in a language, and (3) a “for-free” extraction of an executable definitional interpreter.&lt;/p&gt;

&lt;p&gt;No experience with LLVM or formal verification technologies will be assumed.&lt;/p&gt;

&lt;p&gt;Source can be found on our &lt;a href=&#34;https://github.com/vellvm/vellvm&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
