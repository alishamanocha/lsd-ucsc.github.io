<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Languages, Systems, and Data Lab @ UCSC on Languages, Systems, and Data Lab @ UCSC</title>
    <link>http://lsd-ucsc.github.io/</link>
    <description>Recent content in Languages, Systems, and Data Lab @ UCSC on Languages, Systems, and Data Lab @ UCSC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 31 Aug 2021 19:47:53 -0700</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Languages, Systems, and Data Seminar (Fall 2021)</title>
      <link>http://lsd-ucsc.github.io/lsd-seminar/2021fa/</link>
      <pubDate>Tue, 31 Aug 2021 19:47:53 -0700</pubDate>
      
      <guid>http://lsd-ucsc.github.io/lsd-seminar/2021fa/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:15pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet / The LSD Lab (Engineering 2, Room 398) &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating UCSC students should register for the 2-credit course CSE 280O (let the organizers know if you&amp;rsquo;re an undergrad and need a permission code).&lt;/p&gt;

&lt;p&gt;For fall 2021, we will continue to host the LSD Seminar on Zoom, but local folks can gather in person in the lab to tune into the Zoom talks together.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#sept-24&#34;&gt;Sept. 24&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Welcome!&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-1&#34;&gt;Oct. 1&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://maria-a-schett.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Maria Schett&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-8&#34;&gt;Oct. 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://web.eecs.umich.edu/~takh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Tanvir Khan&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-15&#34;&gt;Oct. 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.seas.upenn.edu/~edinella/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Elizabeth Dinella&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-22&#34;&gt;Oct. 22&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://users.soe.ucsc.edu/~reeselevine/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Reese Levine&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-29&#34;&gt;Oct. 29&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.cmu.edu/~jlwise/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jenna Wise&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-5&#34;&gt;Nov. 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://thok.eu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Thomas Koehler&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-12&#34;&gt;Nov. 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://giuliaguidi.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Giulia Guidi&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-19&#34;&gt;Nov. 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-3&#34;&gt;Dec. 3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://sydgibs.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Sydney Gibson&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;TBD&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;sept-24&#34;&gt;Sept. 24&lt;/h1&gt;

&lt;p&gt;Welcome!&lt;/p&gt;

&lt;h1 id=&#34;oct-1&#34;&gt;Oct. 1&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://maria-a-schett.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Maria Schett&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;oct-8&#34;&gt;Oct. 8&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://web.eecs.umich.edu/~takh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Tanvir Khan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;oct-15&#34;&gt;Oct. 15&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://www.seas.upenn.edu/~edinella/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Elizabeth Dinella&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;oct-22&#34;&gt;Oct. 22&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://users.soe.ucsc.edu/~reeselevine/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Reese Levine&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;oct-29&#34;&gt;Oct. 29&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://www.cs.cmu.edu/~jlwise/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jenna Wise&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;nov-5&#34;&gt;Nov. 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://thok.eu/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Thomas Koehler&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;nov-12&#34;&gt;Nov. 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://giuliaguidi.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Giulia Guidi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;nov-19&#34;&gt;Nov. 19&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;dec-3&#34;&gt;Dec. 3&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://sydgibs.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Sydney Gibson&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; &lt;em&gt;TBD&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Spring 2021)</title>
      <link>http://lsd-ucsc.github.io/lsd-seminar/2021sp/</link>
      <pubDate>Sun, 21 Feb 2021 12:27:37 -0800</pubDate>
      
      <guid>http://lsd-ucsc.github.io/lsd-seminar/2021sp/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:15pm (PT) &lt;br /&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet &lt;br /&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating students should register for the 2-credit course CSE 280O.&lt;/p&gt;

&lt;p&gt;For spring 2021, this seminar is completely virtual and will feature a mix of internal and external speakers.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-2&#34;&gt;April 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://research.aldrinmontana.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aldrin Montana&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Running the Trails of Data Management&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-9&#34;&gt;April 9&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://www.rntz.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Michael Arntzenius&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;PL design and programming by voice&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-16&#34;&gt;April 16&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Achilles Benetopoulos&lt;/td&gt;
&lt;td&gt;HARP: Eliminating Software Supply-Chain Vulnerabilities via Active Learning and Regeneration of String Processing Libraries&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-23&#34;&gt;April 23&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Konstantinos Kallas&lt;/td&gt;
&lt;td&gt;PaSh: A parallelizing shell&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#april-30&#34;&gt;April 30&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Eric Atkinson&lt;/td&gt;
&lt;td&gt;Programming and Reasoning with Partial Observability&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-7&#34;&gt;May 7&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Vadim Zaliva&lt;/td&gt;
&lt;td&gt;HELIX: From Math to Verified Code&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-14&#34;&gt;May 14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.rochester.edu/u/bvalpey/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Benjamin Valpey&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Discovering the Semantics of NVIDIA&amp;rsquo;s SASS ISA&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-21&#34;&gt;May 21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Zeeshan Lakhani&lt;/td&gt;
&lt;td&gt;Polarized Functional Programming v0.1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#may-28&#34;&gt;May 28&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Philippa Cowderoy&lt;/td&gt;
&lt;td&gt;Information Aware Type Systems and Telescopic Constraint Trees&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#june-4&#34;&gt;June 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Ranysha Ware&lt;/td&gt;
&lt;td&gt;Battle for Bandwidth: Evaluating Congestion Control Deployability For The Internet&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;april-2&#34;&gt;April 2&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://research.aldrinmontana.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aldrin Montana&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Running the Trails of Data Management&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The demise of Moore&amp;rsquo;s law and Dennard scaling have swung a pendulum back towards computational storage&amp;ndash;disk drives equipped with modest processors and working memory. As was the case when the earliest ``active drives&amp;rdquo; were developed over three decades ago, moving computational kernels closer to where the data is stored presents an opportunity to improve data processing and retrieval performance by alleviating bottlenecks at CPUs that can no longer promise exponential increases in performance over time. We explore this opportunity in a 3-way collaboration between industry and academia with the goal of showing the benefits provided by computational storage devices for scientific analysis workloads. The analysis workloads are based on use cases for the Human Cell Atlas (HCA) and the UCSC Genomics Institute, the computational storage devices are architected and designed by Seagate, and the system that brings these together is architected by our declarative programmable storage research group at UCSC. This talk uses trail running as a fun metaphor to detail the context and directions of our collaboration that spans data management, single-cell RNA sequencing, and a storage system that leverages computational storage devices.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Aldrin is a 3rd year PhD student at UC Santa Cruz advised by Peter Alvaro, but works extensively with Carlos Maltzahn (UCSC), Jeff LeFevre (UCSC), and Philip Kufeldt (Seagate). Aldrin received his B.S. and M.S. in computer science from Cal Poly, San Luis Obispo working with Alex Dekhtyar on a collaborative, microbial source tracking project with professors and students in the biology and biochemistry departments. Before joining UCSC’s PhD program, Aldrin has worked on data management of genomic variants at a biotech company, Personalis, Inc. His research interests are primarily in data management systems and bioinformatics, but also span programming languages, storage systems, and software engineering.&lt;/p&gt;

&lt;h1 id=&#34;april-9&#34;&gt;April 9&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;http://www.rntz.net/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Michael Arntzenius&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; PL design and programming by voice&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Many programmers and other computer users suffer from repetitive strain injuries (RSI) of the hand that make using a keyboard for extended periods painful. For some kinds of RSI, therapy or surgery may resolve the problem, but in recalcitrant cases sometimes the only option is to reduce or cease typing. So what does a programmer do if they can&amp;rsquo;t type?One option is to use your voice. Speech recognition technology has advanced by leaps and bounds over the past decade, but most people&amp;rsquo;s ideas about voice-driven UI are based on convenient but limited voice assistants like Siri or Alexa, or at best dictation or prose-writing tools. What does a voice interface for expert users look like? A small but growing community of programmers, many affected by RSI, have been developing and using tools that explore this question.I suffer from RSI and use a voice control tool called Talon to program, control my computer, and write my thesis; but I&amp;rsquo;m also a programming languages researcher, and so I find it natural to wonder: how might PL research intersect with voice control? In this talk, I&amp;rsquo;ll try my best to answer that question, as well as a few others:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;What is voice coding like?  What unique challenges does it present compared with keyboard coding?&lt;/li&gt;
&lt;li&gt;What can we learn from this about designing voice interfaces for expert users?  Specifically, how can programming languages better support voice coding?&lt;/li&gt;
&lt;li&gt;How does a voice control system work?  What does it have in common with PL implementation?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Depending on how you count, Michael Arntzenius is somewhere between a 4th- and a 9th-year PhD student. He works with Neel Krishnaswami on Datafun, an attempt to combine the bottom-up deductive query language Datalog with higher-order typed functional programming. He is interested in monotonicity as a unifying and simplifying theme in incremental, concurrent, and distributed computation; and generally in the theory, design, and implementation of programming systems.&lt;/p&gt;

&lt;h1 id=&#34;april-16&#34;&gt;April 16&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Achilles Benetopoulos&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; HARP: Eliminating Software Supply-Chain Vulnerabilities via Active Learning and Regeneration of String Processing Libraries&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Software supply-chain attacks are becoming an important security concern. These attacks focus on a dependency of the target rather than the target itself and often affect the target as well as other consumers of that dependency. We propose active library learning and regeneration (ALR) techniques for inferring and reconstructing the core functionality of a black-box software dependency. Using increasingly sophisticated rounds of exploration, ALR generates inputs, provides these inputs to the dependency, and observes the dependency’s outputs and interactions to infer a model of the dependency’s behavior captured in a domain-specific language. We present HARP, an ALR system for string processing dependencies. We apply HARP to successfully regenerate string-processing libraries in JavaScript, Python, and C/C++. In the majority of cases, HARP completes the regeneration in less than a minute, remains fully compatible with the original library, and achieves performance indistinguishable from the original library. We also demonstrate that HARP can eliminate vulnerabilities associated with libraries targeted in a number of highly visible security incidents of the JavaScript ecosystem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Achilles Benetopoulos is a backend software engineer at Plum Fintech. He received a Masters degree in Engineering from the National Technical University of Athens. He is interested in exploring better ways of building robust and performant distributed systems. Starting in the fall, he will be joining UC Santa Cruz as a graduate student advised by Peter Alvaro, to work towards this goal. When he gets too frustrated by computers, he cooks.&lt;/p&gt;

&lt;h1 id=&#34;april-23&#34;&gt;April 23&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Konstantinos Kallas&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; PaSh: A parallelizing shell&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk I will present PaSh, a new shell that exposes data parallelism in POSIX shell scripts. To achieve that, PaSh proposes: (i) an order-aware dataflow model that captures a fragment of the shell, (ii) a set of dataflow transformations that extract parallelism and have been proven to be correct, (iii) a lightweight framework that captures the correspondence of shell commands and order-aware dataflow nodes, and (iv) a just-in-time compilation framework that allows for effective compilation despite the dynamic nature of the shell. PaSh is open-source and you can try it out today here: &lt;a href=&#34;https://github.com/andromeda/pash&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/andromeda/pash&lt;/a&gt;. If you want to learn more about it you can read our paper that will appear in EuroSys 2021 (next week) here: &lt;a href=&#34;https://arxiv.org/abs/2007.09436&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://arxiv.org/abs/2007.09436&lt;/a&gt; and if you want to learn more about the dataflow model you can read the paper that introduces it and proves the correctness of the transformations here: &lt;a href=&#34;https://arxiv.org/abs/2012.15422&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://arxiv.org/abs/2012.15422&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Konstantinos Kallas is a 3rd year PhD student at the University of Pennsylvania working with Rajeev Alur. They are broadly interested in all things PL, distributed systems, and greek folk mountain music. Recently, together with Nikos Vasilakis and several other amazing people they have been working on invigorating the research on the shell. They are also working on partial order semantics for distributed stream processing and programming models for serverless. You can find more information about them here: &lt;a href=&#34;https://angelhof.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://angelhof.github.io/&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;april-30&#34;&gt;April 30&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Eric Atkinson&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Programming and Reasoning with Partial Observability&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Computer programs are increasingly being deployed in partially-observable environments. A partially-observable environment is an environment whose state is not completely visible to the program, but from which the program receives partial observations. Developers typically deal with partial observability by writing a &lt;em&gt;state estimator&lt;/em&gt; that, given observations, attempts to deduce the hidden state of the environment. In safety-critical domains, to formally verify safety properties developers may write an &lt;em&gt;environment model&lt;/em&gt;. The model captures the relationship between observations and hidden states and is used to prove the software correct.&lt;/p&gt;

&lt;p&gt;In my talk, I will present a new methodology for writing and verifying programs in partially observable environments. I will present &lt;em&gt;belief programming&lt;/em&gt;, a programming methodology where developers write an environment model that the program runtime automatically uses to perform state estimation. A belief program dynamically updates and queries a belief state that captures the possible states the environment could be in. To enable verification, I will present &lt;em&gt;Epistemic Hoare Logic&lt;/em&gt;, which reasons about the possible belief states of a belief program the same way that classical Hoare logic reasons about the possible states of a program. I will develop these concepts by explaining a semantics and a program logic for a simple core language called BLIMP. I will also discuss a case study in which we used BLIMP to implement a verified controller for the Mars Polar Lander, and I will evaluate the performance of a C implementation of BLIMP.&lt;/p&gt;

&lt;p&gt;Paper link: &lt;a href=&#34;https://dl.acm.org/doi/10.1145/3428268&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://dl.acm.org/doi/10.1145/3428268&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Eric Atkinson is a 6th year PhD student at MIT advised by Michael Carbin. His primary research interests involve using programming language tools to help developers manage both probabilistic and nondeterministic uncertainty.&lt;/p&gt;

&lt;h1 id=&#34;may-7&#34;&gt;May 7&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Vadim Zaliva&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; HELIX: From Math to Verified Code&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk we will presents HELIX, a code generation and formal
verification system with a focus on the intersection of
high-performance and high-assurance numerical computing. This allowed
us to build a system that could be fine-tuned to generate efficient
code for a broad set of computer architectures while providing formal
guarantees of such generated code&amp;rsquo;s correctness.&lt;/p&gt;

&lt;p&gt;The method we used for high-performance code synthesis is the
algebraic transformation of vector and matrix computations into a
dataflow optimized for parallel or vectorized processing on target
hardware. The abstraction used to formalize and verify this technique
is an operator language used with semantics-preserving
term-rewriting. We use sparse vector abstraction to represent partial
computations, enabling us to use algebraic reasoning to prove parallel
decomposition properties.&lt;/p&gt;

&lt;p&gt;HELIX provides a formal verification foundation for rewriting-based
algebraic code synthesis optimizations, driven by an external
oracle. Presently HELIX uses SPIRAL as an oracle deriving the rule
application order. The SPIRAL system was developed over the years and
successfully applied to generate code for various numeric
algorithms. Building on its sound algebraic foundation, we generalize
and extend it in the direction of non-linear operators, towards a new
theory of partial computations, applying formal language theory and
formal verification techniques.&lt;/p&gt;

&lt;p&gt;HELIX is developed and proven in Coq proof assistant and demonstrated
on a real-life example of verified high-performance code generation of
the dynamic window safety monitor for a cyber-physical robot system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Vadim Zaliva works on formal verifications of computer programs,
presently as a Senior Research Associate at Cambridge University and
previously as part of his Ph.D. at Carnegie Mellon University. His
diverse academic interests in addition to formal methods range from
computer security to machine learning and gesture recognition. With
20+ years of experience in the design and implementation of commercial
software, he has worked through the ranks of the software industry
from software engineer to CTO, CEO, and company founder.&lt;/p&gt;

&lt;h1 id=&#34;may-14&#34;&gt;May 14&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.rochester.edu/u/bvalpey/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Benjamin Valpey&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Discovering the Semantics of NVIDIA&amp;rsquo;s SASS ISA&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this work, we specify a formal semantics of NVIDIA&amp;rsquo;s SASS instruction set, the ISA that is actually executed by NVIDIA GPUs.  We introduce the ROCetta approach for discovering the semantics of a target language that requires the semantics a source language, and the ability to obtain a translation from the source to the target language.   Using this approach, we have discovered and verified the semantics of 421 SASS instructions.  In addition, our verification effort was able to uncover 18 bugs in the CUDA compiler&amp;rsquo;s translation of single-instruction PTX programs.  In some cases, bugs were only caught during verification and were missed by the testing framework, which lacked a test for inputs that trigger the bug. Furthermore, verification of 3,581 programs took 14 minutes when run in parallel, while running the full test suite against hardware took upwards of 30 minutes.  The low cost of verification, along with its superior ability to detect bugs, makes it an invaluable tool to detect bugs that occur in the translation of small programs.&lt;/p&gt;

&lt;h1 id=&#34;may-21&#34;&gt;May 21&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Zeeshan Lakhani&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Polarized Functional Programming v0.1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; When designing a new, real-world type system, where would you start? Looking for
examples, you may notice that a language like Typescript has a myriad of
advanced typing features, though they&amp;rsquo;re oriented toward trying to
capture JavaScript&amp;rsquo;s many dynamic idioms and (now) lengthy history of existing
programs. Furthermore, even with these advanced features, the language is not
sound, i.e. certain operations cannot be known to be type-safe at compile-time.
Looking elsewhere, like in the ML family of languages, you&amp;rsquo;ll see a powerful
type inference mechanism helping to free programmers from the burden of
numerous, explicit type annotations. Yet, as new research-driven type extensions
have been incorporated, the need for explicit annotations or pre-processing
steps has increased in certain situations. As the complexity of our programs and
the properties about them that we&amp;rsquo;d like to statically guarantee grow, how far
can just typechecking take us while remaining sound and without us having to
associate proofs with our programs?&lt;/p&gt;

&lt;p&gt;The answer is pretty far. Lightweight verification through refinement types is
catching on. Most &lt;em&gt;modern&lt;/em&gt; languages, e.g. Rust, OCaml, Dotty/Scala, come out of
the box with sum types or enumerated variants and integrations for extended
static code analysis. Our answer to these questions lies in the powerful
relationship between static analysis and type theory and how to treat evaluation
(essentially, eager versus lazy) as first-class.&lt;/p&gt;

&lt;p&gt;In this talk, I will present our work-in-progress research on a polarized
functional programming language based on the call-by-push-value (CBPV)
λ-calculus, which allows for the mixing of both call-by-name and call-by-value
evaluation inside of a single program via a kind-like operator, shifting between
positive and negative types. We extend this polarized calculus further with a
transparent and equirecursive interpretation of mixed-inductive-and-coinductive datatypes,
allowing us to leverage strong structural subtyping and datasort refinements over sums and
intersections. Additionally, typechecking works bidirectionally in our system,
meaning that terms can be checked to a certain type or synthesized as a
certain type, which scales well for adding various expressive type features to
our language.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Zeeshan is the founder of Papers We Love and PWLConf, as well as an organizer. He&amp;rsquo;s also
the Director of Research and Development at BlockFi working on various data and program
analysis projects. And, he&amp;rsquo;s a PhD student at Carnegie Mellon University&amp;rsquo;s School of
Computer Science, studying Programming Languages under Frank Pfenning.&lt;/p&gt;

&lt;h1 id=&#34;may-28&#34;&gt;May 28&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Philippa Cowderoy&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Information Aware Type Systems and Telescopic Constraint Trees&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; What does conservation of information have to do with type systems? Are type checkers specialised operating systems? Can we understand dataflow in type systems or are we doomed to drown in it?&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll present a highly familiar type system in pursuit of an `Information Aware&amp;rsquo; style, using information effects to reveal data flow and help in implementing a checker. I also calculate a general, scoped, constraint-based representation of typechecking problems from the typing rules.&lt;/p&gt;

&lt;p&gt;And then, because why not? Let&amp;rsquo;s toy with substructural systems and maybe even incremental checking!&lt;/p&gt;

&lt;p&gt;Warning: talk may contain willfully creative use of long-standing concepts&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Philippa Cowderoy is a professional procrastinator and amateur computer scientist, having dropped out of the University of Nottingham as an undergraduate in 2007.&lt;/p&gt;

&lt;p&gt;Somehow this still hasn&amp;rsquo;t put her off being frustrated with her tools on a increasingly deeper level. When she is bored enough, she is now mining particularly meta veins of frustration shared by others in the PL community.&lt;/p&gt;

&lt;p&gt;In her copious free (if not high-quality) time she plays too many games and spends too little time around cats.&lt;/p&gt;

&lt;h1 id=&#34;june-4&#34;&gt;June 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Ranysha Ware&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Battle for Bandwidth: Evaluating Congestion Control Deployability For The Internet&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The stability of the Internet relies on congestion control algorithms (CCAs) to efficiently and fairly share limited network resources. Dozens of congestion control algorithms have been proposed in the past 30 years, however, we still lack a good way to decide whether a new algorithm is reasonable to deploy on the Internet. As we will show in this talk, new algorithms can be dramatically unfair to widely-deployed legacy algorithms. For example, we prove that Google&amp;rsquo;s new CCA, BBR, will always consume a fixed fraction of the link when competing with any number of Cubic flows.&lt;/p&gt;

&lt;p&gt;Given the threat of poor performance due to competing heterogeneous CCAs, in this talk we discuss considerations for deploying new CCAs on the Internet. While past efforts have focused on achieving fairness or friendliness between new algorithms and legacy algorithms, we instead advocate for an approach centered on quantifying and limiting harm caused by the new algorithm on the status quo. We argue that a harm-based approach is more practical, more future proof, and handles a wider range of quality metrics than traditional notions of fairness and friendliness.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt;  Ranysha Ware is a PhD student in Carnegie Mellon University’s Computer Science Department, co-advised by Professor Justine Sherry and Professor Srinivasan Seshan. Her bailiwick is computer networking. Her current research focuses on challenges arising from the deployment of new transport protocols and congestion control algorithms in the Internet. Ranysha earned her M.S. (2015) from UMass Amherst and B.S (2013) from SUNY New Paltz. She is a recipient of the IRTF Applied Networking Research Prize, Facebook Emerging Scholar Award, and National GEM Consortium Fellowship.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Winter 2021)</title>
      <link>http://lsd-ucsc.github.io/lsd-seminar/2021wi/</link>
      <pubDate>Sat, 02 Jan 2021 21:45:29 -0800</pubDate>
      
      <guid>http://lsd-ucsc.github.io/lsd-seminar/2021wi/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:15pm (PT) &lt;br/&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet &lt;br/&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating students should register for the 2-credit course CSE 280O.&lt;/p&gt;

&lt;p&gt;For winter 2021, this seminar is completely virtual and will feature a mix of internal and external speakers.&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-8&#34;&gt;Jan. 8&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Introductions and social time&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-15&#34;&gt;Jan. 15&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://very.science/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kenny Foner&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Dialectic: Pragmatic, Efficient Session Types for Async Rust&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-22&#34;&gt;Jan. 22&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.princeton.edu/~nhossain/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Naorin Hossain&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;TransForm: Formally Specifying Transistency Models and Synthesizing Enhanced Litmus Tests&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#jan-29&#34;&gt;Jan. 29&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://aviral.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aviral Goel&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;On the Design, Implementation, and Use of Laziness in R&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-5&#34;&gt;Feb. 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.victoraying.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Victor Ying&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Parallelizing Sequential Code with Compiler-Hardware Co-Design&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-12&#34;&gt;Feb. 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://koronkevi.ch/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Paulette Koronkevich&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;The ANF Translation Preserves Dependent Types up to Extensional Equality&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-19&#34;&gt;Feb. 19&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Kamala Ramasubramanian&lt;/td&gt;
&lt;td&gt;ACT now: Aggregate Comparison of Traces for Incident Localization&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#feb-26&#34;&gt;Feb. 26&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://prakashmurali.bitbucket.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Prakash Murali&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Closing the Gap between Quantum Algorithms and Hardware using Compilation and Architecture&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-5&#34;&gt;March 5&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.vinujoseph.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Vinu Joseph&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Programmable Neural Network Compression with Correctness Emphasis&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#march-12&#34;&gt;March 12&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Daniel Bittman&lt;/td&gt;
&lt;td&gt;Twizzler: Evolving Operating Systems for Non-volatile Memory&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;jan-8&#34;&gt;Jan. 8&lt;/h1&gt;

&lt;p&gt;Introductions and social time&lt;/p&gt;

&lt;h1 id=&#34;jan-15&#34;&gt;Jan. 15&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://very.science/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kenny Foner&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Dialectic: Pragmatic, Efficient Session Types for Async Rust&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Session types have long promised the ability to enforce complex temporal invariants about message ordering in distributed systems, guaranteeing that a well-session-typed program always correctly follows a messaging protocol to its end. Despite their potential, these type systems have seen relatively little adoption in the mainstream. In part, this is due to their inherent reliance on linear typing, a feature not present and difficult to emulate in most popular languages. Recently, this has changed with the emergence of Rust, a systems programming language built atop a flexible &amp;ldquo;ownership type system&amp;rdquo; to track reference aliasing. Although Rust enforces in actuality a form of affine typing (weaker than the linear typing most formal session-typed calculi require) it&amp;rsquo;s enough to build a library for session types that statically enforces the slightly-weaker guarantee that a program correctly follows a messaging protocol so long as it is running, but may quit the session early. Of course, this is the best we can hope to get in the real world! Networks go down, computers crash, and hardware just plain breaks. For session types to be broadly adopted, they must survive contact with this real and unpredictable world—and equally, with the real and unpredictable people who want to use them in their programs.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve just released version 0.2 of &lt;a href=&#34;https://docs.rs/dialectic&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Dialectic&lt;/a&gt;: a library for pragmatic, succinct, efficient session types in Rust. Dialectic embraces Rust&amp;rsquo;s burgeoning ecosystem of high-performance async networking by being polymorphic over any backend transport used to convey messages between parties. Unlike many libraries for session types, Dialectic assumes that the other party might break protocol or disconnect at any time, and is designed to gracefully handle such failures without compromising type safety.  Dialectic is designed to be used for writing specifications and programs of every size from small to large, and provides what&amp;rsquo;s needed to write modular specifications and implementations of complex protocols—and not merely the regular session types expressible in most libraries, but all context-free session types.&lt;/p&gt;

&lt;p&gt;More than merely showing off this cool thing I&amp;rsquo;m working on, I want to talk about the design process that went into making it. Designing a programming paradigm—whether you want to call it an embedded domain-specific language or merely a library—is a multi-faceted puzzle spanning considerations from psychological familiarity to formal computability. My hope is that in walking through this case study in embedded language design, we can spark more thoughts about how we as PL researchers can play in this field together and design beautiful, useful tools.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kenny Foner (kwf@very.science) is a senior software engineer at Bolt Labs working on privacy-preserving financial technology for everyone. They have a master&amp;rsquo;s degree in programming languages from the University of Pennsylvania, where they worked on a smorgasbord of fun things from laziness to random testing. When they&amp;rsquo;re not writing Rust, they&amp;rsquo;re usually somewhere in the forest.&lt;/p&gt;

&lt;h1 id=&#34;jan-22&#34;&gt;Jan. 22&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.princeton.edu/~nhossain/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Naorin Hossain&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; TransForm: Formally Specifying Transistency Models and Synthesizing Enhanced Litmus Tests&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Memory consistency models (MCMs) have been formulated as a mechanism for expressing the legal ordering and visibility of shared memory accesses in hardware and software. They are fundamental for ensuring heterogeneous components of a system execute and interact as expected to prevent hardware-induced bugs in real-world programs. However, ISA-level MCMs are limited to defining the behavior of only user-facing assembly instructions and do not account for virtual memory implementations that may result in the execution of 1) hardware-level state updates and 2) system-level interactions. Both are capable of accessing memory and may affect program outcomes, thus making them software-visible. As a result, memory transistency models (MTMs) have been coined as a superset of MCMs to additionally capture and enforce virtual memory-aware ordering rules. However, no prior work enabled the formal specification or analysis of MTMs.&lt;/p&gt;

&lt;p&gt;TransForm fills this gap by introducing an axiomatic vocabulary for formally specifying MTMs that builds on the standard axiomatic vocabulary traditionally used for describing MCMs. It provides new constructs for modeling transistency-specific features such as hardware-level state updates and system-level interactions. Using this new axiomatic vocabulary, MTMs can be formally specified and used with TransForm’s synthesis engine to synthesize litmus tests enhanced with transistency features, called enhanced litmus tests. This talk will cover TransForm’s axiomatic vocabulary and synthesis engine, as well as a case study performed with TransForm to formally define an approximate MTM for Intel x86 processors.&lt;/p&gt;

&lt;h1 id=&#34;jan-29&#34;&gt;Jan. 29&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;http://aviral.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Aviral Goel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; On the Design, Implementation, and Use of Laziness in R&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In this talk, I will present the design and implementation of call-by-need in R, and a data-driven study of how generations of programmers have put laziness to use in their code. In our study, we analyze 16,707 R packages and observe the creation of 270.9 B promises. Our data suggest that there is little supporting evidence to assert that programmers use laziness to avoid unnecessary computation or to operate over infinite data structures. For the most part R code appears to have been written without reliance on and in many cases even knowledge of, delayed argument evaluation. The only significant exception is a small number of packages which leverage call-by-need for meta-programming. I will discuss how we intend to leverage these insights to remove laziness from R and enable non-intrusive migration of code from lazy to eager evaluation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Aviral Goel is a Computer Science Ph.D. student at Northeastern University, advised by Professor Jan Vitek. He received his Bachelor&amp;rsquo;s degree in Electronics and Communication Engineering from Netaji Subhas Institute of Technology, India.&lt;/p&gt;

&lt;p&gt;He is interested in improving tools and techniques for data science applications. He is enabling R programmers to write faster and bug-free code by migrating the language from lazy-by-default to lazy-on-demand semantics.&lt;/p&gt;

&lt;p&gt;He is also involved in the development of a type system for R.&lt;/p&gt;

&lt;h1 id=&#34;feb-5&#34;&gt;Feb. 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.victoraying.com/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Victor Ying&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Parallelizing Sequential Code with Compiler-Hardware Co-Design&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Today, most code still runs on expensive, power-hungry processors that prioritize single-thread performance. Speculative parallelization is an enticing approach to accelerate computation while retaining the ease of sequential programming, by launching tasks in parallel before knowing if they are independent. Unfortunately, prior speculative parallelizing compilers and architectures achieved limited speedups due to high costs of recovering from misspeculation and hardware scalability bottlenecks.&lt;/p&gt;

&lt;p&gt;We present T4, a parallelizing compiler that executes sequential programs as trees of tiny timestamped tasks. T4 targets the recent Swarm architecture, which presents new opportunities and challenges for automatic parallelization. T4 introduces novel compiler techniques to expose parallelism aggressively across the entire program, breaking applications into tiny tasks of tens of instructions each. Task trees unfold their branches in parallel to enable high task-spawn throughput while exploiting selective aborts to recover from misspeculation cheaply. T4 exploits parallelism across function calls, loops, and loop nests; performs new transformations to reduce task spawn costs and avoid false sharing; and exploits data locality among fine-grain tasks. As a result, T4 scales several hard-to-parallelize SPEC CPU2006 benchmarks to tens of cores, where prior work attained little or no speedup.&lt;/p&gt;

&lt;p&gt;For more information, please visit &lt;a href=&#34;swarm.csail.mit.edu&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;swarm.csail.mit.edu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Victor Ying is a 5th year PhD student at MIT, advised by Daniel Sanchez. He works on parallel architectures, compilers, and programming models. Victor&amp;rsquo;s recent work focuses on redesigning abstractions between hardware and software to make it as easy to exploit multicore parallelism as it is to write ordinary sequential programs. His prior work includes Boolean satisfiability solvers, scheduling machine learning workloads on hardware accelerators, and embedded and distributed systems.&lt;/p&gt;

&lt;h1 id=&#34;feb-12&#34;&gt;Feb. 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://koronkevi.ch/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Paulette Koronkevich&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; The ANF Translation Preserves Dependent Types up to Extensional Equality&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Many programmers use dependently-typed languages like Coq to
machine-verify high-assurance software. However, existing compilers for
these languages provide no guarantees after compiling, nor when linking
after compilation. Type-preserving compilers preserve guarantees encoded
in types, then use type checking to verify compiled code and ensure safe
linking with external code. Unfortunately, dependent type systems are
highly sensitive to syntactic changes, including compilation, so
preserving them through a compiler pass is difficult.&lt;/p&gt;

&lt;p&gt;In this talk, I will present some examples of why dependent typing is
difficult to preserve through simple syntactic changes. I will also
present our solution to preserving dependent types through the ANF
translation, a necessary transformation towards compiling a functional
language down to machine code. Our ANF translation preserves dependent
types, provided that the target type system has a way to encode these
syntactic semantics-preserving changes. We encode these by including
extensional equality in our target type system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Paulette Koronkevich is a second year graduate student (finishing
MSc and starting PhD) at the University of British Columbia, working
with William J. Bowman. She has a undergraduate degree in computer
science from Indiana University. Her interests include compilers, cats,
and cooking.&lt;/p&gt;

&lt;h1 id=&#34;feb-19&#34;&gt;Feb. 19&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Kamala Ramasubramanian&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; ACT now: Aggregate Comparison of Traces for Incident Localization&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Incidents in production systems are common and downtime is expensive. Applying an appropriate mitigating action quickly, such as changing a specific firewall rule or routing around a broken network link, saves money. Identifying where to mitigate is time-consuming since a single failure can produce widespread effects. Knowing how different system events relate to each other is necessary to quickly identify where to mitigate. Our approach, Aggregate Comparison of Traces (ACT), localizes incidents by comparing sets of traces (which capture events and their relationships for individual requests) sampled from the most recent steady-state operation and during an incident. In our quantitative experiments, we conduct hundreds of simulations and show that ACT is able to identify exactly where to mitigate in all but a few cases.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kamala Ramasubramanian is a PhD candidate at University of California, Santa Cruz advised by Peter Alvaro. She works on understanding, implementing and troubleshooting distributed systems by reasoning about observed system executions. She recently became interested in system verification and how it may overlap with her current work. She is a vegetarian foodie, likes to CrossFit and wants to try surfing.&lt;/p&gt;

&lt;h1 id=&#34;feb-26&#34;&gt;Feb. 26&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://prakashmurali.bitbucket.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Prakash Murali&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Closing the Gap between Quantum Algorithms and Hardware using Compilation and Architecture&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; In recent years, quantum computing (QC) hardware has progressed considerably with small systems being prototyped by industry and academic vendors. However, there is a huge gap between the resource requirements of promising applications and the hardware that is buildable now; qubit counts and operational noise constraints of applications exceed hardware capabilities by 5-6 orders of magnitude. Our work seeks to enable practical QC by bridging this gap: from the top with novel compiler techniques and algorithmic optimizations to reduce application requirements and from the bottom via system architectures efficiently exploiting scarce QC resources.&lt;/p&gt;

&lt;p&gt;In this talk, we present two cross-cutting optimizations that narrow the applications-to-hardware resource gap. First, we present noise-adaptive compilation techniques that optimize applications for the spatio-temporal noise variations seen in real QC systems. Using real executions, we demonstrate average fidelity improvements of 3X using noise-adaptivity, compared to industry compiler tools. Second, on the architecture front, we study instruction set design issues considering application requirements and hardware gate calibration overheads. Current QC systems either use ISAs with a single two-qubit gate type or families of continuous gate sets. Using architectural simulations based on Google and Rigetti hardware, we show that QC instruction sets with 4-8 two-qubit gate types are best suited for expressing application requirements, while incurring tractable calibration overheads. In response to our work, several industry vendors have included noise-adaptivity and its extensions as part of their toolflows and adjusted device architecture to expose more native operations and hardware characterization data.&lt;/p&gt;

&lt;h1 id=&#34;march-5&#34;&gt;March 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Vinu Joseph&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Programmable Neural Network Compression with Correctness Emphasis&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Deep neural networks (DNNs) frequently contain far more weights, represented at higher precision, than are required for the specific task which they are trained to perform.
Consequently, they can often be compressed using techniques such as weight pruning and quantization that reduce both the model size and inference time without appreciable loss in accuracy.
However, finding the best compression strategy and corresponding target sparsity for a given DNN, hardware platform, and optimization objective currently requires expensive, frequently manual, trial-and-error experimentation.
In this talk, we introduce a programmable system for model compression called Condensa. Users programmatically compose simple operators, in Python, to build more complex and practically interesting compression strategies.
Given a strategy and user-provided objective (such as minimization of running time), Condensa uses a novel Bayesian optimization-based algorithm to automatically infer desirable sparsities.
Our experiments real-world DNNs demonstrate memory footprint and hardware runtime throughput improvements of 188x and 2.59x, respectively, using at most ten samples per search.
We have released a reference implementation of &lt;a href=&#34;https://github.com/NVlabs/condensa&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Condensa&lt;/a&gt;. Next, we will talk about our recent correctness extension where we preserve not just the overall accuracy but also metrics relating to model fairness and interpretability.
To achieve this, we augment the compression loss function with terms arising from the teacher-student learning paradigm and show how to automatically tune the associated parameters.
We demonstrate the effectiveness of our approach on multiple compression schemes and accuracy recovery algorithms using several different real-world network architectures.
We obtain a significant reduction of up to 4.1X in the number of mismatches between the compressed and reference models, while also achieving a significant reduction in class-wise disparate impact metrics compared to the reference models.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Vinu Joseph is a Ph.D. candidate in Computer Science at the School of Computing at the University of Utah, Salt Lake City, working on efficient deep learning computing, robustness, and security of deep learning algorithms, advised by Prof. Ganesh Gopalakrishnan.
He is one of the five recipients of the NVIDIA Graduate fellowship, the recipients were selected based on their academic achievements and area of research.
Prior to graduate studies, Vinu worked at ARM Inc. During his tenure at ARM, he was a recipient of the Bravo award for developing the programmer’s model for verifying real-time (‘R’) profile architecture which provides high-performing processors for safety-critical environments.
Vinu’s current research focuses on optimizing deep neural network-based systems for performance and scalability. More broadly, His research is at the intersection of systems, programming languages, and machine learning, to create a more efficient, performant, secure, privacy-preserving, and correct software.
His Ph.D. research has been mainly focused on deep neural network compression for resource-efficient inference and robustness. He is generously supported by an NVIDIA Ph.D. fellowship, mentored by Saurav Muralidharan and Michael Garland, he developed Condensa: A Programming System for Model Compression and Optimization.&lt;/p&gt;

&lt;h1 id=&#34;march-12&#34;&gt;March 12&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; Daniel Bittman&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Twizzler: Evolving Operating Systems for Non-volatile Memory&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Byte addressable, non-volatile memory (NVM) demands that we rethink the entire system stack. Twizzler is an operating system designed for the near-future of NVM on the memory bus. It removes the kernel from the I/O path, provides programs with direct access to NVM, enabling simpler and more efficient long-term operations on persistent data. Twizzler provides a clean-slate programming model for persistent data, realizing the vision of Unix in a world of NVM. It does this through a pervasive notion of data identity coupled with an efficient design for persistent pointers that allows programmers to construct persistent data structures in a large, persistent, global address space. This talk will present an overview of Twizzler and discuss upcoming directions for Twizzler in security, distribution, and programming languages.Bio&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Daniel is a PhD candidate at UC Santa Cruz, advised by Ethan Miller and Peter Alvaro. His interests are in kernel programming and design, security, non-volatile memory, and concurrent programming. His current project is on developing an operating system for non-volatile memories and developing operating system designs and interfaces for better programming and data models in such an environment.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Languages, Systems, and Data Seminar (Fall 2020)</title>
      <link>http://lsd-ucsc.github.io/lsd-seminar/2020fa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lsd-ucsc.github.io/lsd-seminar/2020fa/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Time&lt;/strong&gt;: Fridays, noon - 1:15pm (PT)&lt;br/&gt;
&lt;strong&gt;Location&lt;/strong&gt;: The Internet &lt;br/&gt;
&lt;strong&gt;Organizers&lt;/strong&gt;: Lindsey Kuper and Tyler Sorensen &lt;br/&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The Languages, Systems, and Data Seminar meets weekly to discuss interesting topics in the areas of programming languages, systems, databases, formal methods, security, software engineering, verification, architecture, and beyond.  Our goal is to encourage interactions and discussions between students, researchers, and faculty with interests in these areas.  The seminar is open to everyone interested.  Participating students should register for the 2-credit course CSE 280O.&lt;/p&gt;

&lt;p&gt;For fall 2020, this seminar is completely virtual.  We are excited to welcome a roster of external speakers from around the world!&lt;/p&gt;

&lt;p&gt;Talks will be advertised on the &lt;a href=&#34;https://groups.google.com/g/ucsc-lsd-seminar-announce&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ucsc-lsd-seminar-announce&lt;/a&gt; (for anyone) and &lt;a href=&#34;https://groups.google.com/a/ucsc.edu/g/lsd-group/members&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;lsd-group&lt;/a&gt; (for UCSC-affiliated people) mailing lists.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Speaker&lt;/th&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-2&#34;&gt;Oct. 2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;Social event and class introduction&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-9&#34;&gt;Oct. 9&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://mpg.is/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Matthías Páll Gissurarson&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Weakening Type Systems for Faster Prototyping&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-16&#34;&gt;Oct. 16&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://wen.works/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Wen Kokke&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;An introduction to Session Types&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-23&#34;&gt;Oct. 23&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kalevalp.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kalev Alpernas&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Correct and Secure Serverless Computing&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#oct-30&#34;&gt;Oct. 30&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://software-lab.org/people/Daniel_Lehmann.html&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Daniel Lehmann&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Everything Old is New Again: Binary Security of WebAssembly&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-6&#34;&gt;Nov. 6&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://umazalakain.info/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Uma Zalakain&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Mechanising the Linear π-Calculus&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-13&#34;&gt;Nov. 13&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.cmu.edu/~kqy/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Katherine Ye&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Penrose: from mathematical notation to beautiful diagrams&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#nov-20&#34;&gt;Nov. 20&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://sites.google.com/lehigh.edu/jacobnelson/home&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jacob Nelson&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Bundled References: An Abstraction for Highly-Concurrent Linearizable Range Queries&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-4&#34;&gt;Dec. 4&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.cornell.edu/~avh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Alexa VanHattum&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Vectorization for Digital Signal Processors via Equality Saturation&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;#dec-11&#34;&gt;Dec. 11&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cis.upenn.edu/~euisuny/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Irene Yoon&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Modular, compositional, and executable semantics for LLVM IR&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;oct-2&#34;&gt;Oct. 2&lt;/h1&gt;

&lt;p&gt;Class introduction&lt;/p&gt;

&lt;h1 id=&#34;oct-9&#34;&gt;Oct. 9&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt;  &lt;a href=&#34;https://mpg.is/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Matthías Páll Gissurarson&lt;/a&gt; (&lt;em&gt;Chalmers University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Weakening Type Systems for Faster Prototyping&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Types and type systems are great to provide the compiler with a partial specification of our programs, but it can often be tricky to write code that matches said specification. In this talk, I will demonstrate how we can allow developers to opt-in to a weaker type system &amp;ldquo;just get it to compile&amp;rdquo;, and what we can do to &amp;ldquo;fix&amp;rdquo; the code during compilation so that it matches the specification provided using synthesis and coercions, and hint to the developer what the issue is and how they might fix it.&lt;/p&gt;

&lt;h1 id=&#34;oct-16&#34;&gt;Oct. 16&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://wen.works/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Wen Kokke&lt;/a&gt; (&lt;em&gt;University of Edinburgh&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; An introduction to Session Types&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Much like the λ-calculus is the foundational calculus for functions, the π-calculus is the foundational calculus for message-passing concurrency. Both are terrifyingly powerful, in the sense that if you can compute something, you can do it using these languages. They&amp;rsquo;re also very scary, in the sense that you can easily write functions that &amp;ldquo;go wrong&amp;rdquo;, e.g., by getting different kinds of data mixed up, looping forever, or just getting stuck. In this talk, I&amp;rsquo;ll introduce the fundamentals of the π-calculus, and the continued effort to tame its potential for going wrong, while leaving as much of its power as possible intact. I&amp;rsquo;ll do all of this by analogy to the λ-calculus, and I&amp;rsquo;ll finish up by talk about concurrent λ-calculus—basically the answer to the question &amp;ldquo;What do I get if I smash my λs and πs together really hard?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;(The talk starts with a brief recap of the relevant bits of the untyped and simply-typed λ-calculus, just in case you could use a refresher.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Wen is a programming languages researcher at the University of Edinburgh, where she works on session types. She is also a researcher at Heriot-Watt University, where she works on lightweight verification for neural networks. In her spare time, she enjoys cooking and runs a small art space.&lt;/p&gt;

&lt;h1 id=&#34;oct-23&#34;&gt;Oct. 23&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://kalevalp.github.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Kalev Alpernas&lt;/a&gt; (&lt;em&gt;Tel Aviv University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Correct and Secure Serverless Computing&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Serverless computing is a popular cloud computing paradigm that allows for easy deployment, rapid prototyping,
 and effortless, near-unlimited scalability. However, serverless computing can provide these benefits by introducing several restrictions and limitations on cloud applications, including limiting task execution time, requiring the use of ephemeral execution
 environments, and requiring that programs adopt an event-driven programming model. These limitations make it harder to write correct and secure applications.&lt;/p&gt;

&lt;p&gt;In this talk I will present two projects aimed at bridging these security and correctness gaps. The first—Trapeze—is
 a runtime IFC system that guarantees termination-sensitive non-interference,
 ensuring that sensitive data never leaks from a serverless application. The second—Watchtower—is a runtime monitoring system that checks for violation of arbitrary temporal correctness properties that cross-cut the entire application reporting to the user
 when violations occur. Watchtower also includes a record-and-replay component for locally reproducing and debugging property violations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Kalev is a 4th year PhD candidate at Tel Aviv University, under the supervision of Prof. Mooly Sagiv. His
 research interests are in the intersection of serverless computing and PL/formal methods.&lt;/p&gt;

&lt;h1 id=&#34;oct-30&#34;&gt;Oct. 30&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;http://software-lab.org/people/Daniel_Lehmann.html&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Daniel Lehmann&lt;/a&gt; (&lt;em&gt;University of Stuttgart&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Everything Old is New Again: Binary Security of WebAssembly&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; WebAssembly is an increasingly popular, low-level binary format designed
to run code in browsers and on other platforms safely and securely, by
strictly separating code and data, enforcing types, and limiting
indirect control flow. Still, vulnerabilities in memory-unsafe source
languages can translate to vulnerabilities in WebAssembly binaries. We
have analyzed to what extent vulnerabilities are exploitable in
WebAssembly binaries, and how this compares to native code. We find that
many classic vulnerabilities which, due to common mitigations, are no
longer exploitable in native binaries, are completely exposed in
WebAssembly. Moreover, WebAssembly enables unique attacks, such as
overwriting supposedly constant data or manipulating the heap using a
stack overflow. In this talk, we will explain several attack primitives
that allow an attacker (i) to write arbitrary memory, (ii) to overwrite
sensitive data, and (iii) to trigger unexpected behavior by diverting
control flow or manipulating the host environment. This can ultimately
lead to new forms of cross-site scripting in the browser or remote code
execution on Node.js. We will also demonstrate one of our three
end-to-end exploits, which cover three different WebAssembly platforms.
In our quantitative evaluation of real-world WebAssembly binaries, we
also measure how likely our attack primitives are feasible in practice.
Overall, our findings show a perhaps surprising lack of binary security
in WebAssembly. Finally, we will discuss some potential mitigations and
give recommendations on how to harden WebAssembly binaries in the future.&lt;/p&gt;

&lt;h1 id=&#34;nov-6&#34;&gt;Nov. 6&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://umazalakain.info/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Uma Zalakain&lt;/a&gt; (&lt;em&gt;University of Glasgow&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Mechanising the Linear π-Calculus&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The π-calculus is a computational model for communication and concurrency. The
linear π-calculus restricts the π-calculus by demanding that every communication
channel is used exactly once. This results in more fine grained control over
communication, avoids race conditions, and is in itself enough to serve as a
target language to which the session-typed π-calculus can be compiled to.&lt;/p&gt;

&lt;p&gt;This talk will focus on mechanizing the linear π-calculus. I will first present
a mechanized syntax and an operational semantics for the untyped π-calculus. On
top of that, I will use leftover typing to define a resource-aware type system
that is parametrized by a set of usage coalgebras. I will compare this type
system with its more traditional alternative, and comment on some of its type
safety properties.&lt;/p&gt;

&lt;p&gt;Finally, I will briefly introduce some of our ongoing research, which aims to
mechanize the decidable typechecking of the linear π-calculus. We do so by
borrowing ideas from co-contextual type checking algorithms and applying them to
the linear π-calculus. This results in a constraint satisfaction problem that,
when satisfied, returns type substitutions that can be used to mechanically
build typing derivations for terms.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Uma is a 2nd year PhD student at the University of Glasgow, where she works on the machine verification of typed process calculi under the supervision of Dr Ornela Dardha.
On her spare time she enjoys going out along the local riverbank for a run, and she uses every opportunity she has to hike through the Italian Alps and the Basque Pyrenees.&lt;/p&gt;

&lt;h1 id=&#34;nov-13&#34;&gt;Nov. 13&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.cmu.edu/~kqy/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Katherine Ye&lt;/a&gt; (&lt;em&gt;Carnegie Mellon University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Penrose: from mathematical notation to beautiful diagrams&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; How do you design a system for automatically visualizing mathematics? In this talk I will discuss the approach taken in our SIGGRAPH 2020 paper to build a tool, called Penrose, for creating mathematical diagrams.&lt;/p&gt;

&lt;p&gt;The basic functionality of Penrose is to translate abstract statements written in familiar math-like notation into one or more possible visual representations. Rather than rely on a fixed library of visualization tools, the visual representation is user-defined in a constraint-based specification language; diagrams are then generated automatically via constrained numerical optimization. The system is user-extensible to many domains of mathematics, and is fast enough for iterative design exploration. In contrast to tools that specify diagrams via direct manipulation or low-level graphics programming, Penrose enables rapid creation and exploration of diagrams that faithfully preserve the underlying mathematical meaning. We demonstrate the effectiveness and generality of the system by showing how it can be used to illustrate a diverse set of concepts from mathematics and computer graphics.&lt;/p&gt;

&lt;p&gt;For more information (and pictures!), please see our paper page:
&lt;a href=&#34;https://penrose.ink/siggraph20&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://penrose.ink/siggraph20&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;nov-20&#34;&gt;Nov. 20&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://sites.google.com/lehigh.edu/jacobnelson/home&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Jacob Nelson&lt;/a&gt; (&lt;em&gt;Lehigh University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Bundled References: An Abstraction for Highly-Concurrent Linearizable Range Queries&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; As the name suggests, range queries provide the capability to return all values of a set, whose keys are contained in a given range. In a concurrent setting, this particular operation presents challenges since it can be long running. To offer linearizable range queries, we must ensure that the operations observe a consistent snapshot of the data structure even in the midst of ongoing point operations (i.e. get, put and delete). Bundled references are a new building block to provide linearizable range query operations for highly concurrent linked data structures. At its core, a bundled reference maintains the history of a given data structure link to allow range queries to traverse a path through the data structure corresponding to a particular moment in time. By traversing only links that were &amp;ldquo;alive&amp;rdquo; at the range queries outset, a range query observes a view of the data structure that is consistent with the target atomic snapshot and is made of the minimal amount of nodes that should be accessed to preserve linearizability.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt; Jacob Nelson is a third-year PhD student at Lehigh University in Bethlehem, PA. His interests encompass a wide range of systems topics including highly concurrent data structures and distribution using remote direct memory access (RDMA). His most recent work is focused on how to leverage high performance one-sided RDMA operations to build a data-movement oriented transactional key-value store. Check out his &lt;a href=&#34;https://sites.google.com/lehigh.edu/jacobnelson&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;website&lt;/a&gt; for more info!&lt;/p&gt;

&lt;h1 id=&#34;dec-4&#34;&gt;Dec. 4&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cs.cornell.edu/~avh/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Alexa VanHattum&lt;/a&gt; (&lt;em&gt;Cornell University&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Vectorization for Digital Signal Processors via Equality Saturation&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; Compute-heavy embedded systems, from augmented reality to 5G networking, rely on specialized hardware in the form of digital signal processors (DSPs). However, DSPs are designed to prioritize energy efficiency and predictability over programmability, with simple in-order architectures that offer little hardware-provided parallelism. Existing auto-vectorizing compilers can struggle to optimize small linear algebra kernels that rely on complex data movements. An expert can reach state-of-the-art performance by hand-writing specialized implementations to use vector instructions, but they must repeat this manual effort for each size instance. In this talk, I will describe Diospyros, a search-based compiler that automates this task of finding efficient vectorizations for smaller linear algebra kernels. Diospyros combines two automated reasoning techniques, symbolic evaluation and equality saturation over rewrite rules, to vectorize computations with irregular structure. We show that Diospyros outperforms DSP libraries by 2.8x on average and demonstrate how search-based techniques can help users reach performance competitive with expert tuning with less manual effort.&lt;/p&gt;

&lt;h1 id=&#34;dec-11&#34;&gt;Dec. 11&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Speaker:&lt;/strong&gt; &lt;a href=&#34;https://www.cis.upenn.edu/~euisuny/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Irene Yoon&lt;/a&gt; (&lt;em&gt;University of Pennsylvania&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; Modular, compositional, and executable semantics for LLVM IR&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Abstract:&lt;/strong&gt; The LLVM framework has been a long-time favorite for compiler enthusiasts. It is both a widely used industrial-strength compiler (most recognizably, Apple’s latest macOS and iOS development tools) and a popular research tool (winning the ACM Software Systems Award in 2012).&lt;/p&gt;

&lt;p&gt;How do we best ensure that LLVM-based tools (compilers, optimizers, code instrumentation passes, etc.) do what they’re supposed to — especially for safety- or security-critical applications?&lt;/p&gt;

&lt;p&gt;This talk is an introduction to a novel formal semantics for a large, sequential subset of the LLVM IR, mechanized in the Coq proof assistant. We will see how the use of modern semantic reasoning techniques allow us to write a &lt;em&gt;compositional, modular, and executable&lt;/em&gt; semantics. In particular, I will discuss how the development of an &lt;em&gt;interaction tree&lt;/em&gt;-based semantics gives us (1) expressive combinators for defining compositional semantics, (2) a modular separation of concerns for effects in a language, and (3) a “for-free” extraction of an executable definitional interpreter.&lt;/p&gt;

&lt;p&gt;No experience with LLVM or formal verification technologies will be assumed.&lt;/p&gt;

&lt;p&gt;Source can be found on our &lt;a href=&#34;https://github.com/vellvm/vellvm&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;../&#34;&gt;Archive&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
